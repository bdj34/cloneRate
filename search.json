[{"path":"https://bdj34.github.io/cloneRate/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 cloneRate authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-dataAnalysis.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Analysis of human blood data","text":"First, ’ll load packages want use. ’ll plotting trees using ape package function ape::plot.phylo() along ape functions. cloneRate installed, already ape package. ’ll also using ggplot2 make plots, well survival, ggsurvfit, car downstream analysis. can installed CRAN shown : ’ll also set colors ’ll use plotting. palette taken ","code":"# Load and attach our package cloneRate library(cloneRate)  # Load and attach ape library(ape)  # Install ggplot2 if necessary, then load and attach it with library() if (!requireNamespace(\"ggplot2\")) {   install.packages(\"ggplot2\") } library(ggplot2)  # Install survival if necessary, then load and attach it with library() if (!requireNamespace(\"survival\")) {   install.packages(\"survival\") } library(survival)  # Install ggsurvfit if necessary, then load and attach it with library() if (!requireNamespace(\"ggsurvfit\")) {   install.packages(\"ggsurvfit\") } library(ggsurvfit)  # Install car if necessary, then load and attach it with library() if (!requireNamespace(\"car\")) {   install.packages(\"car\") } library(car) colorPal <- c(\"#000000\", \"#E69F00\", \"#56B4E9\", \"#009E73\", \"#F0E442\", \"#0072B2\", \"#D55E00\", \"#CC79A7\")"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-dataAnalysis.html","id":"data-exploration","dir":"Articles","previous_headings":"","what":"Data exploration","title":"Analysis of human blood data","text":"First, let’s examine realCloneData, contains necessary data reproduce analysis. two lists contained dataset, one contains full reconstructed tree individual timepoint (named fullTrees), one contains specific clones full trees (named cloneTrees). require clone must least n=10 tips (cells) included cloneTrees. discuss requirement simulation vignette. now, let’s split two different variables clarity.","code":"summary(cloneRate::realCloneData) #>            Length Class  Mode #> fullTrees  30     -none- list #> cloneTrees 42     -none- list fullTrees.list <- cloneRate::realCloneData$fullTrees cloneTrees.list <- cloneRate::realCloneData$cloneTrees"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-dataAnalysis.html","id":"full-trees","dir":"Articles","previous_headings":"Data exploration","what":"Full trees","title":"Analysis of human blood data","text":"Let’s start looking full tree single individual, “PD9478”. individuals study sequenced multiple timepoints, refer ID (“PD9478”) timepoint (“_1”) get specific tree fullTrees.list. case, timepoint timepoint 1, let’s take look full tree “PD9478_1”. data comes work Williams et al. see tree class phylo(http://ape-package.ird.fr/misc/FormatTreeR_24Oct2012.pdf), fairly straightforward encoding phylogenetic trees R. Let’s plot tree:","code":"# Let's see the class of the tree PD9478 <- fullTrees.list$PD9478_1 class(PD9478) #> [1] \"phylo\" # Plot the full tree from individual PD9478 at timepoint 1 PD9478 <- fullTrees.list$PD9478_1  # Plot, then add scale and title plot.phylo(PD9478,   direction = \"downwards\",   show.tip.label = FALSE, edge.width = 2,   edge.color = c(rep(\"black\", 2), \"red\", \"#0070C0\", rep(\"black\", (200))) ) axisPhylo(side = 2, backward = FALSE, las = 1) title(main = \"PD9478 full tree\", ylab = \"Time (years)\")"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-dataAnalysis.html","id":"clone-trees","dir":"Articles","previous_headings":"Data exploration","what":"Clone trees","title":"Analysis of human blood data","text":"went simulation vignette, ’ll notice tree looks quite bit different ones simulated. tree, clear example somatic clonal expansion. know authors produced data (see Williams et al. Fig. 3 PD9478), sampled cells within clone mutation JAK2 gene (occurs along red edge) DNMT3A gene (occurs along blue edge). mutations known important clonal expansions blood. Let’s look closely clone see can learn tree.  Now tree clonal expansion looks lot like trees simulate! suggests growth rate cell within clone roughly cells within clone. can now apply methods clone tree shown !","code":"# Load the clone tree from our cloneTrees.list PD9478_subClone <- cloneTrees.list[[\"PD9478_1_clone1\"]]  # Plot, then add scale and title plot.phylo(PD9478_subClone,   direction = \"downwards\",   show.tip.label = FALSE, edge.width = 2, ) axisPhylo(side = 2, backward = FALSE, las = 1) title(main = \"PD9478 JAK2 & DNMT3A clone tree\", ylab = \"Time (years)\")"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-dataAnalysis.html","id":"estimating-growth-rates","dir":"Articles","previous_headings":"","what":"Estimating growth rates","title":"Analysis of human blood data","text":"see tree ultrametric know ’s time-based, units years, apply [internalLengths()] [maxLikelihood()] functions. Unfortunately, don’t ground truth compare working real data. However, individual clone longitudinal sequencing data, can use estimate orthogonal growth rate. ’ll come back later (see Validation). First, let’s apply analysis clone trees. give list phylo objects, growth rate functions estimate growth rate separately, returning data.frame row telling us result tree. Oof! Looks like warning… says two trees input “PD5847_1_clone1” “PD4781_1_clone1” binary branching trees. means one node 2 direct descendants. case, ’s big deal. know trees resconstructed mutation data, just mean picked two divisions happened without mutations occurring . Let’s plot one can see happens  can see three descendants single node (node 76), identified edges orange. see lot places multiple splits (coalescence events) quick succession, place 1 node appears split 3. Well, ’s okay, know mutations imperfect way keep track time. saw events one node splits 3, cases one node splits 4+, might concerned. case, can move . functions growth rate estimation equipped handle trees like , throw warnings know ’s happening. Let’s continue, applying [maxLikelihood()] function trees. bad! correlation coefficient around 0.98, estimates method agree well.","code":"# Get maximum likelihood and internal lengths estimates print(round(maxLikelihood(PD9478_subClone)$estimate, 3)) #> [1] 0.516 print(round(internalLengths(PD9478_subClone)$estimate, 3)) #> [1] 0.601 # Apply each of our estimates resultsLengths <- internalLengths(cloneTrees.list) #> Warning in FUN(X[[i]], ...): Tree is not binary. Birth-death branching trees should be binary, #>        but tree resonstruction from data may lead to  3+ descendants from #>        a single parent node. Proceed with caution! Input tree has #>       3 nodes directly descending from a single #>        parent node. A binary tree would only have 2 descendant nodes #>        from each parent node. Tree throwing warning is PD5847_1_clone1 #> Warning in FUN(X[[i]], ...): Tree is not binary. Birth-death branching trees should be binary, #>        but tree resonstruction from data may lead to  3+ descendants from #>        a single parent node. Proceed with caution! Input tree has #>       3 nodes directly descending from a single #>        parent node. A binary tree would only have 2 descendant nodes #>        from each parent node. Tree throwing warning is PD4781_1_clone1 # Plot, highlighting the 3 descendants of node 76. Then add scale and title plot.phylo(cloneTrees.list$PD5847_1_clone1,   edge.width = 2,   direction = \"downwards\", show.tip.label = FALSE,   edge.color = c(     rep(1, 4), \"darkorange\", rep(1, 34),     \"darkorange\", rep(1, 6), \"darkorange\", rep(1, 1000)   ) ) axisPhylo(side = 2, backward = FALSE, las = 1) title(main = \"PD5847 clone 1 tree (multi-branching)\", ylab = \"Time (years)\") resultsMaxLike <- suppressWarnings(maxLikelihood(cloneTrees.list))  # Preview the output print(head(resultsMaxLike[, c(1:3)])) #>                lowerBound  estimate upperBound #> PD34493_clone1 0.09732233 0.1687267  0.2401312 #> PD34493_clone3 0.17680977 0.2316003  0.2863907 #> PD34493_clone4 0.09428111 0.1957285  0.2971758 #> PD41305_clone1 0.17392864 0.3301275  0.4863263 #> PD41305_clone2 0.15906481 0.2757690  0.3924733 #> PD41305_clone3 0.32741598 0.5434498  0.7594836  # Print correlation coefficient of the estimates from the two methods print(stats::cor.test(resultsLengths$estimate, resultsMaxLike$estimate)$estimate) #>       cor  #> 0.9829619"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-dataAnalysis.html","id":"understanding-the-function-outputs","dir":"Articles","previous_headings":"Estimating growth rates","what":"Understanding the function outputs","title":"Analysis of human blood data","text":"functions ([maxLikelihood()] [internalLengths()]) returns data.frame columns, ’ll walk columns mean : lowerBound, estimate, upperBound: growth rate estimate confidence intervals. default 95% confidence intervals, can adjusted setting alpha parameter function input. cloneAgeEstimate estimate time clone initiation sampling. earliest coalescence time clone tree gives us rough estimate clone age, add \\(1/r\\),1 divided growth rate estimate, account expected time initiation first surviving division (first coalescence). ’ll discuss later. sumInternalLengths, sumExternalLengths, extintRatio: sum internal edge lengths, external edge lengths, ratio two. use ratio say whether enough time passed use method (see simulation vignette). Fortunately, real data ratio > 3, can apply methods clone trees. n number tips clone tree. case, corresponds number cells sequenced clone. alpha confidence level. default 0.05, use 1-alpha (default 95%) confidence intervals upper lower bounds. runtime_s runtime method seconds. method method used, helps want combine data.frames different methods plotting. cloneName_result unique name clone corresponding individual ID clone number. individuals Williams paper, individuals sampled multiple timepoints, ID followed “_1”, “_2”, “_3” indicate timepoint.","code":"# Check that column names are the same stopifnot(all(colnames(resultsMaxLike) == colnames(resultsLengths)))  # Print column names colnames(resultsMaxLike) #>  [1] \"lowerBound\"         \"estimate\"           \"upperBound\"         #>  [4] \"cloneAgeEstimate\"   \"sumInternalLengths\" \"sumExternalLengths\" #>  [7] \"extIntRatio\"        \"n\"                  \"alpha\"              #> [10] \"runtime_s\"          \"method\"             \"cloneName_result\""},{"path":[]},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-dataAnalysis.html","id":"metadata","dir":"Articles","previous_headings":"Downstream analysis","what":"Metadata","title":"Analysis of human blood data","text":"Now growth rates, let’s make sense . look inside cloneTrees.list, realize also metadata. Let’s print two examples, one individual Myeloproliferative Neoplasm (MPN), one without: biological /clinical analysis, important : age tells us individual’s age time sampling. know clonal hematopoiesis associated aging. cloneDriver tells us clonal hematopoiesis driver likely leads expansion. diagnosis.age tells us individual diagnosed Myeloproliferative Neoplasm (MPN). individual doesn’t MPN, diagnosis.age NA. malnorm tells us whether individual diagnosed Myeloproliferative Neoplasm (MPN). information already conveyed diagnosis.age, ’s sometimes easier work format. Let’s combine cloneTrees.list metadata one data.frame, can analyze together results running functions. Let’s join data.frames containing metadata results. can use base::cbind() know order metadata order results data.frame. can check comparing cloneName_result cloneName_meta columns, () . ’ll go forward analysis using results data.frame, contains estimates [maxLikelihood()] function metadata. simulation vignette, show maximum likelihood estimate performs best.","code":"# Show the metadata of an individual without MPN print(cloneTrees.list$PD34493_clone1$metadata) #>        ID age cloneName_meta      cloneDriver diagnosis.age malnorm sourcePaper #> 1 PD34493  83 PD34493_clone1 SF3B1:k666n_DelY            NA  Normal       fabre  # And the metadata of an individual with MPN print(cloneTrees.list$PD9478_1_clone1$metadata) #>         ID      age  cloneName_meta                                cloneDriver #> 1 PD9478_1 68.75291 PD9478_1_clone1 JAK2:p.F537_K539delinsL_AND_DNMT3A:p.Y908* #>   diagnosis.age   malnorm sourcePaper #> 1            53 Malignant    williams # Combine all metadata into a single data.frame metadataAll <- do.call(rbind, lapply(cloneTrees.list, function(x) {   return(x$metadata) })) # Combine metadata with estimates using cbind. Check if cloneNames match resultsLengthsMeta <- cbind(resultsLengths, metadataAll) stopifnot(resultsLengthsMeta$cloneName_result == resultsLengthsMeta$cloneName_meta)  resultsMaxLikeMeta <- cbind(resultsMaxLike, metadataAll) stopifnot(resultsLengthsMeta$cloneName_result == resultsLengthsMeta$cloneName_meta)  # Because max. likelihood performs slightly better, use that going forward results <- resultsMaxLikeMeta"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-dataAnalysis.html","id":"recreating-figures","dir":"Articles","previous_headings":"Downstream analysis","what":"Recreating figures","title":"Analysis of human blood data","text":", recreate analysis Figure 5E-G work. just many analyses can done data, don’t limited . split cohort MPN normal, might expect differences growth rates. number sampled cells, average, higher healthy individuals due study design differences, ’re likely pick clones healthy individuals. avoid bias much possible, ’ll compare mean growth rate individuals without MPN. First, want avoid double counting clones appear twice. three clones Williams paper: now, uniqueResults dataframe contains results one clone duplicated pair. Later , want validate estimates, ’ll make use fact data different timepoints clone, showing methods make consistent estimates regardless sampling time use. Validation section.","code":"# If patient ID and clone number are the same, even if timepoint # differs, then we have a duplicate. # Make a new column for patient, removing anything after \"_\" from cloneName_result results$patient <- gsub(\"_.*\", \"\", results$cloneName_result) results$cloneNumber <- gsub(\".*_clone\", \"\", results$cloneName_result)  # Combining patient ID (without timepoint) and clone number # will give us a unique ID for the clone regardless of sampling time results$uniqueCloneID <- paste0(results$patient, \"_\", results$cloneNumber)  # Find which clone IDs appear twice tmp <- table(results$uniqueCloneID) repeatsVec <- names(tmp)[tmp == 2]  # Remove the duplicate with fewer number of cells sequenced, n rowsRemove <- c() for (cloneID in repeatsVec) {   duplicateRows <- which(results$uniqueCloneID == cloneID)   removeIndex <- duplicateRows[which.min(results$n[duplicateRows])]   rowsRemove <- c(rowsRemove, removeIndex) }  uniqueResults <- results[!c(1:nrow(results)) %in% rowsRemove, ] # Check that each unique clone now only appears once (no duplicates) stopifnot(all(table(uniqueResults$uniqueCloneID) == 1))"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-dataAnalysis.html","id":"mpn-vs--normal-fig--5e","dir":"Articles","previous_headings":"Downstream analysis > Recreating figures","what":"MPN vs. Normal (Fig. 5E)","title":"Analysis of human blood data","text":"Now, let’s take mean individual re-create Fig. 5E.","code":"# Get the unique individuals, and initialize vectors uniqueIndividuals <- unique(uniqueResults$patient) individualMeans <- c() malNorm <- c()  # Fill vectors with mean growth rate and MPN status of each individual for (ind in uniqueIndividuals) {   individualMeans <- c(individualMeans, mean(uniqueResults$estimate[uniqueResults$patient == ind]))   malNorm <- c(malNorm, uniqueResults$malnorm[uniqueResults$patient == ind][1]) }  # Combine results into a data.frame mal_vs_norm.df <- data.frame(   \"Patient\" = uniqueIndividuals,   \"meanEstimate\" = individualMeans,   \"malNorm\" = malNorm )  # Run a non-parametric Mann-whitney test to see if they're significantly different nonparamTest <- wilcox.test(meanEstimate ~ malNorm, data = mal_vs_norm.df) print(nonparamTest) #>  #>  Wilcoxon rank sum exact test #>  #> data:  meanEstimate by malNorm #> W = 64, p-value = 0.02853 #> alternative hypothesis: true location shift is not equal to 0  # Set factor ordering for plot and plot using ggplot (Fig. 5E) mal_vs_norm.df$malNorm <- factor(mal_vs_norm.df$malNorm, levels = c(\"Normal\", \"Malignant\")) ggplot(mal_vs_norm.df, aes(x = malNorm, y = meanEstimate)) +   geom_label(label = paste0(\"p = \", round(nonparamTest$p.value, 3)), x = 1.5, y = 1.2) +   geom_boxplot(width = 0.3, aes(color = malNorm), outlier.shape = NA) +   geom_jitter(aes(x = malNorm, y = meanEstimate, color = malNorm), width = .1, size = 2) +   scale_color_manual(values = c(\"black\", \"red\"), labels = c(\"Normal\", \"MPN\")) +   theme_bw() +   ylab(\"Mean net growth rate (r)\") +   xlab(\"\") +   theme(     legend.position = \"none\",     axis.ticks.x = element_blank(), axis.title.x = element_blank()   )"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-dataAnalysis.html","id":"single-vs--multi-driver-fig--5f","dir":"Articles","previous_headings":"Downstream analysis > Recreating figures","what":"Single vs. multi-driver (Fig. 5F)","title":"Analysis of human blood data","text":"Taking results unique clones, uniqueResults, let’s compare growth rates clones either unknown driver single driver, multiple drivers. , ’ll notice handy convention metadata: drivers separated “”, clone “” driver column, multiple drivers:","code":"# Set the multi driver variable according to whether multiple drivers are annotated uniqueResults$multiDriver <- \"Single or unknown\" uniqueResults$multiDriver[grepl(\"AND\", uniqueResults$cloneDriver)] <- \"Multiple\"  # Run a non-parametric test to see if the differences are significant nonParamTest <- wilcox.test(estimate ~ multiDriver, data = uniqueResults) print(nonParamTest) #>  #>  Wilcoxon rank sum exact test #>  #> data:  estimate by multiDriver #> W = 276, p-value = 1.554e-06 #> alternative hypothesis: true location shift is not equal to 0  # Set factor levels to control plot order uniqueResults$multiDriver <- factor(uniqueResults$multiDriver, levels = c(\"Single or unknown\", \"Multiple\"))  # Plot (Fig. 5F) ggplot(uniqueResults, aes(x = multiDriver, y = estimate)) +   geom_boxplot(width = 0.3, aes(color = multiDriver), outlier.shape = NA) +   geom_jitter(aes(x = multiDriver, y = estimate, color = multiDriver), width = .1) +   scale_color_manual(values = c(colorPal[4], colorPal[8])) +   theme_bw() +   geom_label(label = paste0(\"p=\", round(nonParamTest$p.value, 7)), x = 1.5, y = 2) +   ylab(\"Net growth rate (r)\") +   xlab(\"\") +   ggtitle(\"Driver mutations\") +   theme(     legend.position = \"none\", axis.ticks.x = element_blank(),     axis.title.x = element_blank(), plot.title = element_text(hjust = .5)   )"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-dataAnalysis.html","id":"time-from-clone-initiation-to-diagnosis-fig--5g","dir":"Articles","previous_headings":"Downstream analysis > Recreating figures","what":"Time from clone initiation to diagnosis (Fig. 5G)","title":"Analysis of human blood data","text":"discussed results data.frame (output [internalLengths()] [maxLikelihood()]) came clone age estimate, \\(1/r\\) + time sampling back first coalescence. birth rate clone \\(\\) death rate \\(b\\), net growth rate \\(r=-b\\). first coalescence represents first surviving division , neither offspring division die , ’ll account , average, half cells clone. means even sample 10 cells, ’re likely sample least one descendant two offspring, meaning first surviving division earliest coalescence, relative time sampling. know first surviving division occurs? Well, know: birth rate \\(\\) probability survival given individual \\((-b)/\\) \\(r/\\) leads rate surviving divisions equal \\(*r/= r\\). Therefore, expected waiting time clone initiation first surviving division \\(1/r\\). way, let’s see growth rate tells us anything time clone initiation diagnosis. , want use max. growth rate patient, ’s one ’d assume likely drive MPN initiation. don’t understand MPN well though, alternative use recently emerged clone prior diagnosis. ’ll , showing actually give results, probably clone arises later life must fit enough -compete clones already expanded. see 15/19 cases, youngest clone (>= 10 tips) also fit. First, let’s use fit clones stratify mean, reproducing result Figure 5G.  don’t fully understand clonal hematopoiesis MPN, ’s reasonable wonder whether using fittest clone best way compare time diagnosis. alternative, let’s compare youngest clones, seeing growth rate estimates still stratify time diagnosis. turns , youngest clone fittest clone 13 individuals diagnosed MPN. saw case 15 19 individuals including healthy individuals.","code":"# Get the clone IDs of the fittest clone in each patient cloneIDs_max <- sapply(unique(uniqueResults$patient), function(x) {   patient.df <- uniqueResults[uniqueResults$patient == x, ]   cloneID <- patient.df$cloneName_result[which.max(patient.df$estimate)]   cloneID })  # Get the clone IDs of the youngest clone in each patient cloneIDs_youngest <- sapply(unique(uniqueResults$patient), function(x) {   patient.df <- uniqueResults[uniqueResults$patient == x, ]   cloneID <- patient.df$cloneName_result[which.min(patient.df$cloneAgeEstimate)]   cloneID })  # See how much overlap there is between the most recent clone and the highest growth rate table(cloneIDs_max == cloneIDs_youngest) #>  #> FALSE  TRUE  #>     4    15 # Subset the results to only have the fittest clone for each patient maxResults <- uniqueResults[uniqueResults$cloneName_result %in% cloneIDs_max, ]  # Subset to the MPN patients malMax <- maxResults[maxResults$malnorm == \"Malignant\", ]  # Determine time from clone initiation to diagnosis malMax$latency_to_dx <- malMax$cloneAgeEstimate - (malMax$age - malMax$diagnosis.age)  # Stratify the population by the mean growth rate, adding a column \"aboveMean\" malMax$aboveMean <- malMax$estimate > mean(malMax$estimate)  # Use the survival package to see if differences are significant malMax$status <- 1 survivalTest <- survival::survdiff(survival::Surv(time = latency_to_dx, event = status) ~ aboveMean, data = malMax) print(survivalTest$pvalue) #> [1] 0.002628379  # Plot survival curves survfit2(Surv(time = latency_to_dx, event = status) ~ aboveMean, data = malMax) %>%   ggsurvfit() +   labs(     y = \"Probability diagnosis-free\",     x = \"Time from clone initiation (yrs.)\"   ) + scale_color_manual(values = c(colorPal[7], colorPal[3])) +   theme(legend.position = \"none\") +   geom_label(label = paste0(\"p = \", round(survivalTest$pvalue, 4)), x = 45, y = .85, color = \"black\", fill = \"white\") +   geom_label(label = \"r < mean\", x = 40, y = .375, color = colorPal[7], fill = \"white\") +   geom_label(label = \"r > mean\", x = 12, y = .35, color = colorPal[3], fill = \"white\") youngestResults <- uniqueResults[uniqueResults$cloneName_result %in% cloneIDs_youngest, ]  # Subset to the MPN patients malYoungest <- youngestResults[youngestResults$malnorm == \"Malignant\", ]  # Check how much overlap there is between youngest clone and fittest clone in the MPN dataset table(malYoungest$cloneName_result == malMax$cloneName_result) #>  #> TRUE  #>   13"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-dataAnalysis.html","id":"validation","dir":"Articles","previous_headings":"","what":"Validation","title":"Analysis of human blood data","text":"Remember said three cases duplicate clones? Well, estimates worth anything, must consistent. means , three clones, expect estimates similar timepoints. Let’s check :  bad! ’s good consistent, ’s better consistent accurate. , need completely orthogonal way measure clonal growth rates, comes longitudinal data. One clones Williams paper two clones Fabre paper matching longitudinal data. formatted nicely comes package! Let’s now fit logistic curve longitudinal data estimate growth rate one clones, individual PD9478, tree showed beginning vignette. , recreating analysis Figure 6.  Now, let’s see estimate compares maximum likelihood estimate:  , bad! now, ’ll leave others explore. vignette already bit long. now tools reproduce analysis relating real data aspect paper. Hopefully able minutes hours, much better months took !","code":"# Like before, we can find which clone IDs appear twice tmp <- table(results$uniqueCloneID) repeatsVec <- names(tmp)[tmp == 2]  # Subset the results to include only repeated clones repeatResults <- results[results$uniqueCloneID %in% repeatsVec, ]  # Plot the repeated clones ggplot(repeatResults) +   geom_pointrange(data = repeatResults, aes(     x = cloneName_result, y = estimate, ymin = lowerBound,     ymax = upperBound, color = uniqueCloneID   )) +   scale_color_manual(values = colorPal[c(1, 6, 7)]) +   theme_bw() +   ylab(\"Net growth rate estimate (r)\") +   theme(axis.text.x = element_blank(), axis.title.x = element_blank(), legend.title = element_blank()) # Get data from PD9478 PD9478_long <- longitudinalData[longitudinalData$Sample.ID == \"PD9478\", ]  # Get a rough estimate for starting params startingParams <- suppressWarnings(coef(lm(logit(VAF / .5) ~ Age, data = PD9478_long)))  # Fit to a three parameter logistic curve fit <- nls(VAF ~ K / (1 + exp(-(phi2 + r * Age))),   start = list(K = 0.2, phi2 = min(c(-0.000001, startingParams[1])), r = max(c(0.00001, startingParams[2]))),   data = PD9478_long, trace = FALSE, algorithm = \"port\", lower = c(0, -500, 0.00001), upper = c(0.5, 0, 5) )  # Set output equal to summary of longitudinal models output <- summary(fit)  # Assign fitted params r <- output$coefficients[\"r\", 1] t_m <- -output$coefficients[\"phi2\", 1] / r # Get midpoint time by dividing by -1/r K <- output$coefficients[\"K\", 1]  # Get CI for growth rate of longitudinal/logistic model stdError <- output$coefficients[\"r\", \"Std. Error\"] lb <- r - 1.96 * stdError ub <- r + 1.96 * stdError  # Prepare a df for plotting the fit line along with the data x <- c((min(PD9478_long$Age) - 10):(max(PD9478_long$Age) + 10)) # construct a range of x values bounded by the data y <- K / (1 + exp(-(x - t_m) * r)) # curve VAF (3 param model) predict.df <- data.frame(\"x\" = x, \"y\" = y)  # Set color for longitudinal fit info fitColor <- colorPal[6]  # Plot ggplot(PD9478_long, aes(x = Age, y = VAF)) +   theme_bw() +   coord_cartesian(xlim = c(min(x), max(x)), ylim = c(-0.01, 0.52), expand = 0) +   labs(x = \"Person Age (yr)\", y = \"Variant Allele Frequency (VAF)\") +   ggtitle(gsub(\"_\", \" & \", paste0(PD9478_long$Sample.ID[1], \" \", PD9478_long$Gene[1]))) +   geom_line(data = predict.df, aes(x = x, y = y), color = fitColor, linewidth = 1, show.legend = TRUE) +   geom_point(color = \"#808080\", shape = 18, size = 1.5) +   geom_vline(xintercept = t_m, linetype = \"dotted\", color = fitColor, linewidth = .6) +   geom_hline(yintercept = K, linetype = \"dotted\", color = fitColor, linewidth = .6) # Get the single cell estimate from PD9478 clone 1 scPD9478 <- results[results$cloneName_result == \"PD9478_1_clone1\", ]  # Combine orthogonal estimates into one df for plotting combine.df <- data.frame(   \"Clone\" = \"PD9478_1_clone1\",   \"r\" = c(r, scPD9478$estimate),   \"lowerBound\" = c(lb, scPD9478$lowerBound),   \"upperBound\" = c(ub, scPD9478$upperBound),   \"method\" = c(\"longitudinal\", \"max. likelihood\") )  # Plot ggplot(combine.df) +   geom_pointrange(aes(x = method, y = r, ymin = lowerBound, ymax = upperBound)) +   theme_bw() +   theme(axis.title.x = element_blank()) +   ylab(\"Net growth rate (r)\")"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-dataAnalysis.html","id":"references-data-sources","dir":"Articles","previous_headings":"","what":"References / Data sources:","title":"Analysis of human blood data","text":"real world data include produced annotated fascinating papers, advanced capabilities single-cell DNA sequencing. also provide excellent analysis addition provide work. Williams et al. 2022 Mitchell et al. 2022 Fabre et al. 2022 Van Egeren et al. 2021 mathematical methods estimating growth rates build large part work Amaury Lambert : Lambert, 2018 ’s final link paper details methods data analysis. enjoyed color palette plotting, tried use colorblind friendly colors, specifically pulling colors palette designed Bang Wong available .","code":""},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-simulate.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Validating growth rate estimates via simulation","text":"First, ’ll load packages want use. ’ll plotting trees using ape package function ape::plot.phylo() along ape functions. cloneRate installed, already ape package. ’ll also using ggplot2 make plots, can installed CRAN shown : ’ll also set color palette ’ll use plotting. palette taken ","code":"# Load and attach our package cloneRate library(cloneRate)  # Load and attach ape, which will be installed if you've installed cloneRate library(ape)  # Install ggplot2 if necessary, then load and attach it with library() if (!requireNamespace(\"ggplot2\")) {   install.packages(\"ggplot2\") } library(ggplot2) colorPal <- c(\"#000000\", \"#E69F00\", \"#56B4E9\", \"#009E73\", \"#F0E442\", \"#0072B2\", \"#D55E00\", \"#CC79A7\")"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-simulate.html","id":"simulating-trees","dir":"Articles","previous_headings":"","what":"Simulating trees","title":"Validating growth rate estimates via simulation","text":"section, ’ll simulate ultrametric mutation-based trees. Ultrametric just means tips distance root. specific case, ultrametric trees edge lengths units time, ultrametric means tips sampled time. Mutation-based trees edge lengths units mutations. Mutation-based trees typically ultrametric, fluctuations number mutations acquired. ’ll generating trees class phylo, fairly straightforward encoding phylogenetic trees R. ape documentation describing class phylo can found .","code":""},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-simulate.html","id":"ultrametric-trees","dir":"Articles","previous_headings":"Simulating trees","what":"Ultrametric trees","title":"Validating growth rate estimates via simulation","text":"Let’s start ultrametric trees. First, let’s simulate single tree look class phylo. ’ll use function simUltra() package , simulates ultrametric tree. ’ll set birth rate , death rate b, age tree cloneAge, number sampled tips n. Note use cloneAge instead \\(T\\) time T R means TRUE. , best place get info class phylo . functions simulating trees include metadata. Let’s take look metadata included tree. see columns : r, , b: growth rate params. r net growth rate, birth rate b death rate, r=-b cloneAge: time passes, units r, , b. n: number samples birth-death process, producing tree n tips. runtime_seconds: elapsed time generate tree. addStem: Tells us whether tree root edge preceding first split. ’ll show “stem” plots . Now let’s plot tree.  tree plotted , see “stem” edge extending time 0 first split. call splits coalescence events ’ll important methods growth rate estimation. Also, see tree ultrametric, meaning sampled time, case 20 units time birth-death process began. default, ’ll talk units time years, arbitrary. Just make sure units growth rate (per year) time units (years). Let’s apply growth rate estimates tree, seeing estimates close value r used generate tree. two functions estimating growth rate ultrametric tree, ’ll compare performance later : internalLengths(): function sums edge lengths internal edges tree (excluding stem). call sum \\(L_i\\). growth rate calculated \\(r = L_i / n\\) \\(n\\) number sampled tips. maxLikelihood(): function uses maximum likelihood estimation distribution coalescence times, using information tree splits. distribution coalescence times approximated standard logistic distribution scaled \\(1/r\\). Maximizing likelihood observed coalescence times \\(r\\) term gives us estimate. methods detailed recent preprint. know actual growth rate 1, can evaluate estimates . One estimate doesn’t really tell us much though. Let’s try 100. , just set nTrees param equal 100 simUltra() function. can parallelize process parallel package installed simply setting nCores, ’ll leave 1 now. printing elapsed time, see one core takes minute. Let’s apply methods trees. can input either single phylo object, list phylo objects growth rate functions. Either way, ’ll return data.frame row corresponding estimate tree. gave method 100 trees estimate, let’s plot estimates. Remember input trees growth rate 1, want estimates close 1. ’ll use ggplot’s density plot :  bad, ’ll want test formally large range parameter values. later vignette. now, let’s shift attention mutation trees.","code":"# Generate the tree tree <- simUltra(a = 1, b = 0, cloneAge = 20, n = 100)  # We see that the tree is of class phylo class(tree) #> [1] \"phylo\"  # Preview the tree print(tree) #>  #> Phylogenetic tree with 100 tips and 99 internal nodes. #>  #> Tip labels: #>   t77, t23, t62, t75, t36, t59, ... #>  #> Rooted; includes branch lengths. print(tree$metadata) #>   r a b cloneAge   n runtime_seconds addStem #> 1 1 1 0       20 100           0.573   FALSE plot.phylo(tree, direction = \"downwards\", show.tip.label = FALSE) axisPhylo(side = 2, backward = FALSE, las = 1) title(main = \"Simulated tree\", ylab = \"Time\") maxLikelihood(tree)$estimate #> [1] 0.9991583  internalLengths(tree)$estimate #> [1] 0.9886496 ptm <- proc.time() tree.list <- simUltra(a = 1, b = 0, cloneAge = 20, n = 100, nTrees = 100, nCores = 1, addStem = TRUE) print(proc.time()[[\"elapsed\"]] - ptm[[\"elapsed\"]]) #> [1] 54.713 resultsMaxLike <- maxLikelihood(tree.list)  resultsLengths <- internalLengths(tree.list) # Combine for ggplot formatting resultsCombined <- rbind(resultsLengths, resultsMaxLike)  # Plot, adding a vertical line at r=1 because that's the true growth rate ggplot(resultsCombined) +   geom_density(aes(x = estimate, color = method), linewidth = 1.5) +   geom_vline(xintercept = exampleUltraTrees[[1]]$metadata$r) +   theme_bw() +   theme(     axis.text.y = element_blank(), axis.ticks.y = element_blank(),     legend.title = element_blank()   ) +   xlab(\"Net growth rate estimate (r)\") +   ylab(\"Density\") +   scale_color_manual(labels = c(\"Internal lengths\", \"Max. likelihood\"), values = c(\"black\", \"#009E73\"))"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-simulate.html","id":"mutation-trees","dir":"Articles","previous_headings":"Simulating trees","what":"Mutation trees","title":"Validating growth rate estimates via simulation","text":"two ways generate mutation trees: can add mutations time-based ultrametric tree can generate completely new mutation-based tree Either way, process generating mutation trees consists : Generating ultrametric, time-based tree. step required generate new tree edge, draw number mutations poisson distribution mean equal mutation rate nu multiplied edge length time-based tree. Let’s take ultrametric trees just generated convert mutation-based trees. , provide function ultra2mut(): Alternatively, can generate new set mutation trees using function simMut(). won’t run take another minutes, already mutation-based trees generated . want estimate growth rate mutation tree, use sharedMuts() function, works similarly internalLengths() function. However, instead counting internal edge lengths units time, sharedMuts() function counts internal/shared mutations uses mutation rate scale time. , \\(M_i\\) number internal shared mutations, \\(nu\\) mutation rate, \\(n\\) number samples, growth rate estimate \\(r = M_i /(\\nu n)\\). Let’s apply sharedMuts() function trees converted mutation-based. Remember mutation-based trees generated ultrametric trees applied functions maxLikelihood() internalLengths() . Let’s plot estimates together. First, ’ll combine data.frames produced. sharedMuts() function outputs additional column corresponding mutation rate nu. , using rbind full data.frames give error. want look estimates now, ’ll just combine necessary columns data.frame.  looks like ’re right track. , ’s hard tell best. Maximum likelihood seems bit biased high side, estimates seem fall narrow range. Let’s quantitative analysis now hang .","code":"# Set mutation rate equal to 10 muts/year for all trees mutTree.list <- ultra2mut(tree.list, nu = 10) # Set params for ultra tree + a mutation rate mutTree.list2 <- simMut(a = 1, b = 0, cloneAge = 20, n = 100, nTrees = 100, nu = 100, nCores = 1) resultsShared <- sharedMuts(mutTree.list, nu = 10) # Combine the columns with the estimates colsUse <- c(\"lowerBound\", \"estimate\", \"upperBound\", \"method\") resultsAll <- rbind(resultsShared[, colsUse], resultsCombined[, colsUse])  # Plot, adding a vertical line at r=1 because that's the true growth rate ggplot(resultsAll) +   geom_density(aes(x = estimate, color = method), linewidth = 1.5) +   geom_vline(xintercept = exampleUltraTrees[[1]]$metadata$r) +   theme_bw() +   theme(     axis.text.y = element_blank(), axis.ticks.y = element_blank(),     legend.title = element_blank()   ) +   xlab(\"Net growth rate estimate (r)\") +   ylab(\"Density\") +   scale_color_manual(labels = c(\"Internal lengths\", \"Max. likelihood\", \"Shared Muts.\"), values = c(colorPal[1], colorPal[4], colorPal[6]))"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-simulate.html","id":"quantitative-comparisons","dir":"Articles","previous_headings":"","what":"Quantitative comparisons","title":"Validating growth rate estimates via simulation","text":"section, ’ll use ability generate trees order test methods. ’ll focus mainly ultrametric trees, noting mutation-based approach based shared mutations analogous internal lengths method. ’ll see well methods perform, perform well, fail.","code":""},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-simulate.html","id":"max-likelihood-vs--internal-lengths-vs--shared-mutations","dir":"Articles","previous_headings":"Quantitative comparisons","what":"Max likelihood vs. internal lengths vs. shared mutations","title":"Validating growth rate estimates via simulation","text":"want know estimate best. ’ll start making quantiative comparison 100 estimates already simulations previous section. 100 trees enough get idea estimate accurate, can always simulate . won’t though ’ll take bit longer , well, stop somewhere.","code":""},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-simulate.html","id":"root-mean-square-error-rmse","dir":"Articles","previous_headings":"Quantitative comparisons > Max likelihood vs. internal lengths vs. shared mutations","what":"Root Mean Square Error (RMSE)","title":"Validating growth rate estimates via simulation","text":"","code":"# Calculate the RMSE groundTruth <- 1 rmse <- unlist(lapply(   split(resultsAll, resultsAll$method),   function(x) {     sqrt(sum((x$estimate - groundTruth)^2) / length(x$estimate))   } ))  print(rmse) #>    lengths    maxLike sharedMuts  #>  0.1114471  0.1032183  0.1162169"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-simulate.html","id":"mean","dir":"Articles","previous_headings":"Quantitative comparisons > Max likelihood vs. internal lengths vs. shared mutations","what":"Mean","title":"Validating growth rate estimates via simulation","text":"","code":"# Calculate the mean simMean <- unlist(lapply(   split(resultsAll, resultsAll$method),   function(x) {     mean(x$estimate)   } ))  print(simMean) #>    lengths    maxLike sharedMuts  #>   1.029577   1.051004   1.030339"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-simulate.html","id":"standard-deviation","dir":"Articles","previous_headings":"Quantitative comparisons > Max likelihood vs. internal lengths vs. shared mutations","what":"Standard deviation","title":"Validating growth rate estimates via simulation","text":"saw density plot quantified mean, sd, rmse. Maximum likelihood usually performs best Root Mean Square Error (RMSE) even though ’s mean bit higher (usually around 1.04). 100 trees, larger fluctuations, maximum likelihood might higher RMSE methods. shared mutations method typically performs bit worse ultrametric cousin, internalLengths(). randomness poissonian mutation accumulation likely leads wider spread estimates sharedMuts(), explains difference two methods.","code":"# Calculate the standard deviation of our estimates simSD <- unlist(lapply(   split(resultsAll, resultsAll$method),   function(x) {     sd(x$estimate)   } ))  print(simSD) #>    lengths    maxLike sharedMuts  #> 0.10799191 0.09018839 0.11275225"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-simulate.html","id":"coverage-probability","dir":"Articles","previous_headings":"Quantitative comparisons > Max likelihood vs. internal lengths vs. shared mutations","what":"Coverage probability","title":"Validating growth rate estimates via simulation","text":"now, ’ve looked estimate . note methods also provide confidence intervals. default, alpha = 0.05, provide 95% confidence intervals. can change ’d like, 95% seems pretty standard, ’ll use . 95% confidence interval accurate, ’d expect estimates fall within interval 95% time. Let’s check: ’re right around 95%, great! might expect maxLikelihood(), typically lowest RMSE, might best coverage probability. fact, confidence interval maxLikelihood() function narrower. opposite true sharedMuts() widest confidence interval account randomness mutation accumulation. 100 trees, coverage probability rough estimate.","code":"# Calculate the coverage probability of our estimates groundTruth <- 1 simCoverage <- unlist(lapply(   split(resultsAll, resultsAll$method),   function(x) {     # Set insideInterval to TRUE if inside interval and FALSE if outside     insideInterval <- (x$lowerBound < groundTruth & x$upperBound > groundTruth)     # Count TRUE as 1 and FALSE as 0. See the fraction inside interval     sum(insideInterval) / length(insideInterval)   } ))  print(simCoverage) #>    lengths    maxLike sharedMuts  #>       0.94       0.94       0.97"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-simulate.html","id":"varying-parameters","dir":"Articles","previous_headings":"","what":"Varying parameters","title":"Validating growth rate estimates via simulation","text":"far, ’ve looked parameters. Now, ’ll see happens change important parameters birth-death process.","code":""},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-simulate.html","id":"varying-n","dir":"Articles","previous_headings":"Varying parameters","what":"Varying n","title":"Validating growth rate estimates via simulation","text":"One interesting results explore accuracy estimates depends number samples. , ’ll look different n parameter values. keep things running long, can re-use trees n=100 add 100 trees different n values. , let’s show run simUltra() vector input n. First, ’ll generate vector, ’ll call n_vec. Let’s explore small n value, 10, intermediate n value, 30. now, ’ll keep growth rate - b equal 1, ’ll let actual birth death rates vary. total, n_vec length 200. ’ll want make sure a_vec b_vec also length 200. ’ll set nTrees = 200. generate multiple trees, either set single value parameters, vector length nTrees. applies simUltra() simMut(). Let’s generate trees. Note: also take minutes. Now, let’s apply estimates combine data.frames: Finally, can add resultsCombined data.frame , results applying maxLikelihood() internalLengths() set 100 ultrametric trees n = 100. Let’s make plot , showing performance. ’ll use ggplot2::facet_wrap() order show plot various n values. Although different number trees n = 100 case, density plot normalize .  can see, estimates highly dependent number samples. ’d like see density values y-axis three n values, set scales = \"fixed\" facet_wrap() function. ’re interested, can apply quantitative measures data Quantitative comparisons. won’t repeat , show Figure 2 preprint. information also available Supplementary tables, also available .csv files.","code":"n_vec <- c(rep(10, 100), rep(30, 100)) a_vec <- stats::runif(n = 200, min = 1, max = 4) b_vec <- a_vec - 1 n10_n30_trees <- simUltra(   a = a_vec, b = b_vec, cloneAge = 20, n = n_vec,   nTrees = length(n_vec) ) # Apply our estimates for ultrametric trees n10_n30_maxLike <- maxLikelihood(n10_n30_trees) n10_n30_lengths <- internalLengths(n10_n30_trees)  # Combine the estimates n10_n30_both <- rbind(n10_n30_maxLike, n10_n30_lengths) # Merge the results data.frames results_vary_n <- rbind(n10_n30_both, resultsCombined) ggplot(results_vary_n) +   geom_density(aes(x = estimate, color = method), linewidth = 1.5) +   geom_vline(xintercept = exampleUltraTrees[[1]]$metadata$r) +   theme_bw() +   theme(     axis.text.y = element_blank(), axis.ticks.y = element_blank(),     legend.title = element_blank()   ) +   xlim(0, 3) +   xlab(\"Net growth rate estimate (r)\") +   ylab(\"Density\") +   scale_color_manual(     labels = c(\"Internal lengths\", \"Max. likelihood\"),     values = c(\"black\", \"#009E73\")   ) +   facet_wrap(~ factor(paste0(\"n = \", n), levels = c(\"n = 10\", \"n = 30\", \"n = 100\")),     ncol = 1, strip.position = \"bottom\", scales = \"free\", dir = \"v\"   ) #> Warning: Removed 1 rows containing non-finite values (`stat_density()`)."},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-simulate.html","id":"varying-r-andor-cloneage","dir":"Articles","previous_headings":"Varying parameters","what":"Varying r (and/or cloneAge)","title":"Validating growth rate estimates via simulation","text":"noted , can simulate many trees using simUltra() simMut(). , ’ll use simUltra() generate 100 trees various growth rates. similar analysis Figures 3 4 preprint, noting methods struggle small growth rates. Let’s see come conclusion .","code":""},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-simulate.html","id":"varying-r-or-cloneage","dir":"Articles","previous_headings":"Varying parameters > Varying r (and/or cloneAge)","what":"Varying r or cloneAge?","title":"Validating growth rate estimates via simulation","text":"First, address something might otherwise lead confusion; varying r varying cloneAge. think , makes sense. simulate population net growth rate 1 per year 20 years look growth rate 0.5 per year 40 years. ’ll show , first consider fact units meaningless, long ’re consistent. growth rate 1/12 clone age 20*12 exactly growth rate 1 20 units change years months. might bit confusing, let’s plot . First, ’ll simulate tree growth rate 2 30 years compare tree growth rate 0.5 30 years. trees look different. Finally, ’ll add tree growth rate 0.5, run 120 years. said true, see last tree looks like first tree, 0.5 120 2 30. Let’s find : Now, let’s plot using par() show three one plot  trees left right aren’t identical due stochastic nature birth-death process, similar, certainly different tree middle.","code":"# First tree, r = a - b = 2 tree1 <- simUltra(a = 2.5, b = .5, cloneAge = 30, n = 50)  # Second tree, with r = a - b = 0.5 tree2 <- simUltra(a = 1, b = .5, cloneAge = 30, n = 50)  # Third tree, with r = 0.5 but cloneAge = 120 tree3 <- simUltra(a = 1, b = .5, cloneAge = 120, n = 50) par(mfrow = c(1, 3)) ape::plot.phylo(tree1, direction = \"downwards\", show.tip.label = F, main = \"r = 2, cloneAge = 30\") ape::plot.phylo(tree2, direction = \"downwards\", show.tip.label = F, main = \"r = 0.5, cloneAge = 30\") ape::plot.phylo(tree3, direction = \"downwards\", show.tip.label = F, main = \"r = 0.5, cloneAge = 120\")"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-simulate.html","id":"performance-across-r-values","dir":"Articles","previous_headings":"Varying parameters > Varying r (and/or cloneAge)","what":"Performance across r values","title":"Validating growth rate estimates via simulation","text":"Now can arbitrarily choose whether vary r cloneAge. consistency, ’ll vary r, Figures 3 4 preprint. , two options: Simulate fixed r values, showing good problematic Simulate random r values try decipher estimates good aren’t Option 1 essentially Varying n, r instead n, repeating wouldn’t useful. Option 2 also realistic…can pretend don’t know ground truth show decide methods relevant comparing ground truth. Let’s simulate 1000 trees 50 samples n various growth rates r, ranging 0.1 1 per year, run 40 years. take , won’t actually evaluate part vignette. However, full reproduction work recent preprint article, “Reproduce simulation results” can found package website. run code , analyze done, internalLengths() maxLikelihood() functions. However, ’d also apply diagnostic, tells us clones good candidates method, . run clone ’s good candidate, ’ll get warning. Let’s generate tree low growth rate plot .  see tree long internal branches short external branches. indicates process “supercritical” enough (.e. growth rate time low). Quantitatively, means ratio external internal edge lengths low. Let’s try apply methods: estimates quite bit (ground truth estimate 0.1), see warning. warning tells us external internal edge length ratio 3, clone likely good candidate methods. details came 3 cutoff see Figure 4 preprint reproduced analysis article, “Reproduce simulation results” package website. real advantage diagnostic can look tree calculate ratio tell us right away methods applicable. , ’re interested quantitative side , can apply metrics Quantitative comparisons section, longer form analysis article mentioned .","code":"# Uniform ditribution of r used to generate b_vec r_vec <- stats::runif(n = 1000, min = 0.1, max = 1) a_vec <- stats::runif(n = 1000, min = 1, max = 3) b_vec <- a_vec - r_vec  # Input to simUltra() vary_r_trees <- simUltra(a = a_vec, b = b_vec, cloneAge = 40, n = 50, nTrees = length(a_vec)) # Let's call it slowClone slowClone <- simUltra(a = .15, b = .05, n = 50, cloneAge = 40)  # Plot the tree ape::plot.phylo(slowClone, direction = \"downwards\", show.tip.label = F) # Apply our estimates maxLikelihood(slowClone) #> Warning in maxLikelihood(slowClone): External to internal lengths ratio is less than or equal to 3, #>             which means max. likelihood method may not be applicable. Consider #>             using birthDeathMCMC() function, which avoids this issue. #>   lowerBound  estimate upperBound cloneAgeEstimate sumInternalLengths #> 1  0.1568444 0.2041696  0.2514949         42.79279           273.2736 #>   sumExternalLengths extIntRatio  n alpha runtime_s  method #> 1           404.5007    1.480204 50  0.05     0.008 maxLike internalLengths(slowClone) #> Warning in internalLengths(slowClone): External to internal lengths ratio is less than or equal to 3, #>             which means internal lengths method may not be applicable. Consider #>             using birthDeathMCMC() function, which avoids this issue. #>   lowerBound  estimate upperBound cloneAgeEstimate sumInternalLengths #> 1  0.1322519 0.1829668  0.2336817         43.36037           273.2736 #>   sumExternalLengths extIntRatio  n alpha runtime_s  method #> 1           404.5007    1.480204 50  0.05     0.002 lengths"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-simulate.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Validating growth rate estimates via simulation","text":"method simulating trees direct result work Amaury Lambert following paper. mathematical methods estimating growth rates build large part work, linked : Lambert, 2018 ’s final link preprint details methods data analysis. aren’t many colors vignette, tried use colorblind friendly colors, specifically pulling colors palette designed Bang Wong available .","code":""},{"path":"https://bdj34.github.io/cloneRate/articles/reproduce-simResults.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Reproduce simulation results","text":"First, ’ll load packages want use. ’ll plotting trees using ape package function ape::plot.phylo() along ape functions. cloneRate installed, already ape package. ’ll also using ggplot2 make plots, can installed CRAN shown : ’ll also set color palette ’ll use plotting. palette taken ","code":"# Load and attach our package cloneRate library(cloneRate)  # Load and attach ape, which will be installed if you've installed cloneRate library(ape)  # Install ggplot2 if necessary, then load and attach it with library() if (!requireNamespace(\"ggplot2\")) {   install.packages(\"ggplot2\") } library(ggplot2) colorPal <- c(\"#000000\", \"#E69F00\", \"#56B4E9\", \"#009E73\", \"#F0E442\", \"#0072B2\", \"#D55E00\", \"#CC79A7\")"},{"path":"https://bdj34.github.io/cloneRate/articles/reproduce-simResults.html","id":"simulating-trees","dir":"Articles","previous_headings":"","what":"Simulating trees","title":"Reproduce simulation results","text":"section, ’ll simulate ultrametric mutation-based trees. Ultrametric just means tips distance root. specific case, ultrametric trees edge lengths units time, ultrametric means tips sampled time. Mutation-based trees edge lengths units mutations. Mutation-based trees typically ultrametric, fluctuations number mutations acquired. ’ll generating trees class phylo, fairly straightforward encoding phylogenetic trees R. ape documentation describing class phylo can found .","code":""},{"path":"https://bdj34.github.io/cloneRate/articles/reproduce-simResults.html","id":"ultrametric-trees","dir":"Articles","previous_headings":"Simulating trees","what":"Ultrametric trees","title":"Reproduce simulation results","text":"Let’s start ultrametric trees. First, let’s simulate single tree look class phylo. ’ll use function simUltra() package , simulates ultrametric tree. ’ll set birth rate , death rate b, age tree cloneAge, number sampled tips n. Note use cloneAge instead \\(T\\) time T R means TRUE. , best place get info class phylo . functions simulating trees include metadata. Let’s take look metadata included tree. see columns : r, , b: growth rate params. r net growth rate, birth rate b death rate, r=-b cloneAge: time passes, units r, , b. n: number samples birth-death process, producing tree n tips. runtime_seconds: elapsed time generate tree. addStem: Tells us whether tree root edge preceding first split. ’ll show “stem” plots . Now let’s plot tree.  tree plotted , see “stem” edge extending time 0 first split. call splits coalescence events ’ll important methods growth rate estimation. Also, see tree ultrametric, meaning sampled time, case 20 units time birth-death process began. default, ’ll talk units time years, arbitrary. Just make sure units growth rate (per year) time units (years). Let’s apply growth rate estimates tree, seeing estimates close value r used generate tree. two functions estimating growth rate ultrametric tree, ’ll compare performance later : internalLengths(): function sums edge lengths internal edges tree (excluding stem). call sum \\(L_i\\). growth rate calculated \\(r = L_i / n\\) \\(n\\) number sampled tips. maxLikelihood(): function uses maximum likelihood estimation distribution coalescence times, using information tree splits. distribution coalescence times approximated standard logistic distribution scaled \\(1/r\\). Maximizing likelihood observed coalescence times \\(r\\) term gives us estimate. methods detailed recent preprint. know actual growth rate 1, can evaluate estimates . One estimate doesn’t really tell us much though. Let’s try 100. , just set nTrees param equal 100 simUltra() function. can parallelize process parallel package installed simply setting nCores, ’ll leave 1 now. printing elapsed time, see one core takes minutes. Let’s apply methods trees. can input either single phylo object, list phylo objects growth rate functions. Either way, ’ll return data.frame row corresponding estimate tree. gave method 500 trees estimate, let’s plot estimates. Remember input trees growth rate 1, want estimates close 1. ’ll use ggplot’s density plot :  bad, ’ll want test formally large range parameter values. later vignette. now, let’s shift attention mutation trees.","code":"# Generate the tree tree <- simUltra(a = 1, b = 0, cloneAge = 20, n = 100)  # We see that the tree is of class phylo class(tree) #> [1] \"phylo\"  # Preview the tree print(tree) #>  #> Phylogenetic tree with 100 tips and 99 internal nodes. #>  #> Tip labels: #>   t40, t44, t41, t66, t23, t97, ... #>  #> Rooted; includes branch lengths. print(tree$metadata) #>   r a b cloneAge   n runtime_seconds addStem #> 1 1 1 0       20 100           0.646   FALSE plot.phylo(tree, direction = \"downwards\", show.tip.label = FALSE) axisPhylo(side = 2, backward = FALSE, las = 1) title(main = \"Simulated tree\", ylab = \"Time\") maxLikelihood(tree)$estimate #> [1] 0.9725063  internalLengths(tree)$estimate #> [1] 0.94316 ptm <- proc.time() tree.list <- simUltra(a = 1, b = 0, cloneAge = 20, n = 100, nTrees = 500, nCores = 1, addStem = TRUE) print(proc.time()[[\"elapsed\"]] - ptm[[\"elapsed\"]]) #> [1] 271.681 resultsMaxLike <- maxLikelihood(tree.list)  resultsLengths <- internalLengths(tree.list) # Combine for ggplot formatting resultsCombined <- rbind(resultsLengths, resultsMaxLike)  # Plot, adding a vertical line at r=1 because that's the true growth rate ggplot(resultsCombined) +   geom_density(aes(x = estimate, color = method), linewidth = 1.5) +   geom_vline(xintercept = exampleUltraTrees[[1]]$metadata$r) +   theme_bw() +   theme(     axis.text.y = element_blank(), axis.ticks.y = element_blank(),     legend.title = element_blank()   ) +   xlab(\"Net growth rate estimate (r)\") +   ylab(\"Density\") +   scale_color_manual(labels = c(\"Internal lengths\", \"Max. likelihood\"), values = c(\"black\", \"#009E73\"))"},{"path":"https://bdj34.github.io/cloneRate/articles/reproduce-simResults.html","id":"mutation-trees","dir":"Articles","previous_headings":"Simulating trees","what":"Mutation trees","title":"Reproduce simulation results","text":"two ways generate mutation trees: can add mutations time-based ultrametric tree can generate completely new mutation-based tree Either way, process generating mutation trees consists : Generating ultrametric, time-based tree. step required generate new tree edge, draw number mutations poisson distribution mean equal mutation rate nu multiplied edge length time-based tree. Let’s take ultrametric trees just generated convert mutation-based trees. , provide function ultra2mut(): Alternatively, can generate new set mutation trees using function simMut(). won’t run take another minutes, already mutation-based trees generated . want estimate growth rate mutation tree, use sharedMuts() function, works similarly internalLengths() function. However, instead counting internal edge lengths units time, sharedMuts() function counts internal/shared mutations uses mutation rate scale time. , \\(M_i\\) number internal shared mutations, \\(nu\\) mutation rate, \\(n\\) number samples, growth rate estimate \\(r = M_i /(\\nu n)\\). Let’s apply sharedMuts() function trees converted mutation-based. Remember mutation-based trees generated ultrametric trees applied functions maxLikelihood() internalLengths() . Let’s plot estimates together. First, ’ll combine data.frames produced. sharedMuts() function outputs additional column corresponding mutation rate nu. , using rbind full data.frames give error. want look estimates now, ’ll just combine necessary columns data.frame.  looks like ’re right track. , ’s hard tell best. Maximum likelihood seems bit biased high side, estimates seem fall narrow range. Let’s quantitative analysis now hang .","code":"# Set mutation rate equal to 10 muts/year for all trees mutTree.list <- ultra2mut(tree.list, nu = 10) # Set params for ultra tree + a mutation rate mutTree.list2 <- simMut(a = 1, b = 0, cloneAge = 20, n = 100, nTrees = 500, nu = 100, nCores = 1) resultsShared <- sharedMuts(mutTree.list, nu = 10) # Combine the columns with the estimates colsUse <- c(\"lowerBound\", \"estimate\", \"upperBound\", \"method\") resultsAll <- rbind(resultsShared[, colsUse], resultsCombined[, colsUse])  # Plot, adding a vertical line at r=1 because that's the true growth rate ggplot(resultsAll) +   geom_density(aes(x = estimate, color = method), linewidth = 1.5) +   geom_vline(xintercept = exampleUltraTrees[[1]]$metadata$r) +   theme_bw() +   theme(     axis.text.y = element_blank(), axis.ticks.y = element_blank(),     legend.title = element_blank()   ) +   xlab(\"Net growth rate estimate (r)\") +   ylab(\"Density\") +   scale_color_manual(labels = c(\"Internal lengths\", \"Max. likelihood\", \"Shared Muts.\"), values = c(colorPal[1], colorPal[4], colorPal[6]))"},{"path":"https://bdj34.github.io/cloneRate/articles/reproduce-simResults.html","id":"quantitative-comparisons","dir":"Articles","previous_headings":"","what":"Quantitative comparisons","title":"Reproduce simulation results","text":"section, ’ll use ability generate trees order test methods. ’ll focus mainly ultrametric trees, noting mutation-based approach based shared mutations analogous internal lengths method. ’ll see well methods perform, perform well, fail.","code":""},{"path":"https://bdj34.github.io/cloneRate/articles/reproduce-simResults.html","id":"max-likelihood-vs--internal-lengths-vs--shared-mutations","dir":"Articles","previous_headings":"Quantitative comparisons","what":"Max likelihood vs. internal lengths vs. shared mutations","title":"Reproduce simulation results","text":"want know estimate best. ’ll start making quantiative comparison 500 estimates already simulations previous section. 500 trees enough get idea estimate accurate, can always simulate . won’t though ’ll take bit longer , well, stop somewhere.","code":""},{"path":"https://bdj34.github.io/cloneRate/articles/reproduce-simResults.html","id":"root-mean-square-error-rmse","dir":"Articles","previous_headings":"Quantitative comparisons > Max likelihood vs. internal lengths vs. shared mutations","what":"Root Mean Square Error (RMSE)","title":"Reproduce simulation results","text":"","code":"# Calculate the RMSE groundTruth <- 1 rmse <- unlist(lapply(   split(resultsAll, resultsAll$method),   function(x) {     sqrt(sum((x$estimate - groundTruth)^2) / length(x$estimate))   } ))  print(rmse) #>    lengths    maxLike sharedMuts  #>  0.1050952  0.0980218  0.1088562"},{"path":"https://bdj34.github.io/cloneRate/articles/reproduce-simResults.html","id":"mean","dir":"Articles","previous_headings":"Quantitative comparisons > Max likelihood vs. internal lengths vs. shared mutations","what":"Mean","title":"Reproduce simulation results","text":"","code":"# Calculate the mean simMean <- unlist(lapply(   split(resultsAll, resultsAll$method),   function(x) {     mean(x$estimate)   } ))  print(simMean) #>    lengths    maxLike sharedMuts  #>   1.020536   1.044661   1.021371"},{"path":"https://bdj34.github.io/cloneRate/articles/reproduce-simResults.html","id":"standard-deviation","dir":"Articles","previous_headings":"Quantitative comparisons > Max likelihood vs. internal lengths vs. shared mutations","what":"Standard deviation","title":"Reproduce simulation results","text":"saw density plot reflected mean, sd, rmse. Maximum likelihood performs best Root Mean Square Error even though ’s mean bit higher 1.04. likely due lower standard deviation. shared mutations method performs bit worse ultrametric cousin, internalLengths(). randomness poissonian mutation accumulation likely leads wider spread estimates sharedMuts(), probably explains difference two methods.","code":"# Calculate the standard deviation of our estimates simSD <- unlist(lapply(   split(resultsAll, resultsAll$method),   function(x) {     sd(x$estimate)   } ))  print(simSD) #>    lengths    maxLike sharedMuts  #> 0.10317255 0.08734365 0.10684467"},{"path":"https://bdj34.github.io/cloneRate/articles/reproduce-simResults.html","id":"coverage-probability","dir":"Articles","previous_headings":"Quantitative comparisons > Max likelihood vs. internal lengths vs. shared mutations","what":"Coverage probability","title":"Reproduce simulation results","text":"now, ’ve looked estimate . note methods also provide confidence intervals. default, alpha = 0.05, provide 95% confidence intervals. can change ’d like, 95% seems pretty standard, ’ll use . 95% confidence interval accurate, ’d expect estimates fall within interval 95% time. Let’s check: ’re right around 95%, great! might expect maxLikelihood(), lowest RMSE, might best coverage probability. fact, confidence interval maxLikelihood() function accounts expectation maximum likelihood performs bit better, confidence interval narrower. opposite true sharedMuts() widest confidence interval account randomness mutation accumulation.","code":"# Calculate the coverage probability of our estimates groundTruth <- 1 simCoverage <- unlist(lapply(   split(resultsAll, resultsAll$method),   function(x) {     # Set insideInterval to TRUE if inside interval and FALSE if outside     insideInterval <- (x$lowerBound < groundTruth & x$upperBound > groundTruth)     # Count TRUE as 1 and FALSE as 0. See the fraction inside interval     sum(insideInterval) / length(insideInterval)   } ))  print(simCoverage) #>    lengths    maxLike sharedMuts  #>      0.954      0.938      0.964"},{"path":"https://bdj34.github.io/cloneRate/articles/reproduce-simResults.html","id":"varying-parameters","dir":"Articles","previous_headings":"","what":"Varying parameters","title":"Reproduce simulation results","text":"far, ’ve looked parameters. Now, ’ll see happens change important parameters birth-death process.","code":""},{"path":"https://bdj34.github.io/cloneRate/articles/reproduce-simResults.html","id":"varying-n","dir":"Articles","previous_headings":"Varying parameters","what":"Varying n","title":"Reproduce simulation results","text":"One interesting results explore accuracy estimates depends number samples. , ’ll look different n parameter values. keep things running long, can re-use trees n=100 add 150 trees different n values. , let’s show run simUltra() vector input n. First, ’ll generate vector, ’ll call n_vec. Let’s explore small n value, 10, intermediate n value, 30. now, ’ll keep growth rate - b equal 1, ’ll let actual birth death rates vary. total, n_vec length 300. ’ll want make sure a_vec b_vec also length 300. ’ll set nTrees = 300. generate multiple trees, either set single value parameters, vector length nTrees. applies simUltra() simMut(). Let’s generate trees. Note: also take minutes. Now, let’s apply estimates combine data.frames: Finally, can add resultsCombined data.frame , results applying maxLikelihood() internalLengths() set 500 ultrametric trees n = 100. Let’s make plot , showing performance. ’ll use ggplot2::facet_wrap() order show plot various n values. Although different number trees n = 100 case, density plot normalize .  can see, estimates highly dependent number samples. ’d like see density values y-axis three n values, set scales = \"fixed\" facet_wrap() function. ’re interested, can apply quantitative measures data Quantitative comparisons. won’t repeat , show Figure 2 preprint. information also available Supplementary tables, also available .csv files.","code":"n_vec <- c(rep(10, 150), rep(30, 150)) a_vec <- stats::runif(n = 300, min = 1, max = 4) b_vec <- a_vec - 1 n10_n30_trees <- simUltra(   a = a_vec, b = b_vec, cloneAge = 20, n = n_vec,   nTrees = length(n_vec) ) # Apply our estimates for ultrametric trees n10_n30_maxLike <- maxLikelihood(n10_n30_trees) n10_n30_lengths <- internalLengths(n10_n30_trees)  # Combine the estimates n10_n30_both <- rbind(n10_n30_maxLike, n10_n30_lengths) # Merge the results data.frames results_vary_n <- rbind(n10_n30_both, resultsCombined) ggplot(results_vary_n) +   geom_density(aes(x = estimate, color = method), linewidth = 1.5) +   geom_vline(xintercept = exampleUltraTrees[[1]]$metadata$r) +   theme_bw() +   theme(     axis.text.y = element_blank(), axis.ticks.y = element_blank(),     legend.title = element_blank()   ) +   xlim(0, 3) +   xlab(\"Net growth rate estimate (r)\") +   ylab(\"Density\") +   scale_color_manual(     labels = c(\"Internal lengths\", \"Max. likelihood\"),     values = c(\"black\", \"#009E73\")   ) +   facet_wrap(~ factor(paste0(\"n = \", n), levels = c(\"n = 10\", \"n = 30\", \"n = 100\")),     ncol = 1, strip.position = \"bottom\", scales = \"free\", dir = \"v\"   ) #> Warning: Removed 1 rows containing non-finite values (`stat_density()`)."},{"path":"https://bdj34.github.io/cloneRate/articles/reproduce-simResults.html","id":"varying-r-andor-cloneage","dir":"Articles","previous_headings":"Varying parameters","what":"Varying r (and/or cloneAge)","title":"Reproduce simulation results","text":"noted , can simulate many trees using simUltra() simMut(). , ’ll use simUltra() generate 100 trees various growth rates. similar analysis Figures 3 4 preprint, noting methods struggle small growth rates. Let’s see come conclusion .","code":""},{"path":"https://bdj34.github.io/cloneRate/articles/reproduce-simResults.html","id":"varying-r-or-cloneage","dir":"Articles","previous_headings":"Varying parameters > Varying r (and/or cloneAge)","what":"Varying r or cloneAge?","title":"Reproduce simulation results","text":"First, address something might otherwise lead confusion; varying r varying cloneAge. think , makes sense. simulate population net growth rate 1 per year 20 years look growth rate 0.5 per year 40 years. ’ll show , first consider fact units meaningless, long ’re consistent. growth rate 1/12 clone age 20*12 exactly growth rate 1 20 units change years months. might bit confusing, let’s plot . First, ’ll simulate tree growth rate 2 30 years compare tree growth rate 0.5 30 years. trees look different. Finally, ’ll add tree growth rate 0.5, run 120 years. said true, see last tree looks like first tree, 0.5 120 2 30. Let’s find : Now, let’s plot using par() show three one plot  trees left right aren’t identical due stochastic nature birth-death process, similar, certainly different tree middle.","code":"# First tree, r = a - b = 2 tree1 <- simUltra(a = 2.5, b = .5, cloneAge = 30, n = 50)  # Second tree, with r = a - b = 0.5 tree2 <- simUltra(a = 1, b = .5, cloneAge = 30, n = 50)  # Third tree, with r = 0.5 but cloneAge = 120 tree3 <- simUltra(a = 1, b = .5, cloneAge = 120, n = 50) par(mfrow = c(1, 3)) ape::plot.phylo(tree1, direction = \"downwards\", show.tip.label = F, main = \"r = 2, cloneAge = 30\") ape::plot.phylo(tree2, direction = \"downwards\", show.tip.label = F, main = \"r = 0.5, cloneAge = 30\") ape::plot.phylo(tree3, direction = \"downwards\", show.tip.label = F, main = \"r = 0.5, cloneAge = 120\")"},{"path":"https://bdj34.github.io/cloneRate/articles/reproduce-simResults.html","id":"performance-across-r-values","dir":"Articles","previous_headings":"Varying parameters > Varying r (and/or cloneAge)","what":"Performance across r values","title":"Reproduce simulation results","text":"Now can arbitrarily choose whether vary r cloneAge. consistency, ’ll vary r, Figures 3 4 preprint. , two options: Simulate fixed r values, showing good problematic Simulate random r values try decipher estimates good aren’t Option 1 essentially Varying n, r instead n, repeating wouldn’t useful. Option 2 also realistic…can pretend don’t know ground truth show decide methods relevant comparing ground truth. Let’s simulate 200 trees 50 samples various growth rates, ranging 0.1 1 per year, run 40 years. Apply maxLikelihood() function usual… Uh oh… ’s long list warnings. Let’s read see ’s going . ratio external internal lengths measure “supercritical” star-shaped birth-death process . internal lengths top tree, consider star-shaped, ’s good candidate methods, operate assumption supercritical process. means growth rate high enough, enough time passed, coalescence events occur well sampling time. practice, using simulations, show external internal lengths ratio greater 3 good enough apply methods. Let’s apply methods see look applying ratio cutoff. Note ’re Figure 4 preprint. Let’s apply internal lengths method, time suppressing warning. different r values, can’t density plot . ’ll show density plot x axis representing percent error. case, good estimates consolidate around 0. First, ’ll calculate error using estimate column r_vec ground truth values.  bad, rogue estimates > 200% error! many > 50% error. Let’s apply cutoff ratio 3 exclude trees don’t think good candidates methods. Hopefully, get rid poor estimates.  ’d say ’s much better. cut 24 200 trees, eliminating many worst estimates. real advantage can look tree calculate ratio tell us right away methods applicable. , ’re interested quantitative side , can apply metrics Quantitative comparisons section.","code":"# Uniform ditribution of r used to generate b_vec r_vec <- stats::runif(n = 200, min = 0.1, max = 1) a_vec <- stats::runif(n = 200, min = 1, max = 3) b_vec <- a_vec - r_vec  # Input to simUltra() vary_r_trees <- simUltra(a = a_vec, b = b_vec, cloneAge = 40, n = 50, nTrees = length(a_vec)) maxLike_vary_r <- maxLikelihood(vary_r_trees) #> Warning in FUN(X[[i]], ...): External to internal lengths ratio is less than or equal to 3, #>             which means max. likelihood method may not be applicable. Consider #>             using birthDeathMCMC() function, which avoids this issue.  #> Warning in FUN(X[[i]], ...): External to internal lengths ratio is less than or equal to 3, #>             which means max. likelihood method may not be applicable. Consider #>             using birthDeathMCMC() function, which avoids this issue.  #> Warning in FUN(X[[i]], ...): External to internal lengths ratio is less than or equal to 3, #>             which means max. likelihood method may not be applicable. Consider #>             using birthDeathMCMC() function, which avoids this issue.  #> Warning in FUN(X[[i]], ...): External to internal lengths ratio is less than or equal to 3, #>             which means max. likelihood method may not be applicable. Consider #>             using birthDeathMCMC() function, which avoids this issue.  #> Warning in FUN(X[[i]], ...): External to internal lengths ratio is less than or equal to 3, #>             which means max. likelihood method may not be applicable. Consider #>             using birthDeathMCMC() function, which avoids this issue.  #> Warning in FUN(X[[i]], ...): External to internal lengths ratio is less than or equal to 3, #>             which means max. likelihood method may not be applicable. Consider #>             using birthDeathMCMC() function, which avoids this issue.  #> Warning in FUN(X[[i]], ...): External to internal lengths ratio is less than or equal to 3, #>             which means max. likelihood method may not be applicable. Consider #>             using birthDeathMCMC() function, which avoids this issue.  #> Warning in FUN(X[[i]], ...): External to internal lengths ratio is less than or equal to 3, #>             which means max. likelihood method may not be applicable. Consider #>             using birthDeathMCMC() function, which avoids this issue.  #> Warning in FUN(X[[i]], ...): External to internal lengths ratio is less than or equal to 3, #>             which means max. likelihood method may not be applicable. Consider #>             using birthDeathMCMC() function, which avoids this issue.  #> Warning in FUN(X[[i]], ...): External to internal lengths ratio is less than or equal to 3, #>             which means max. likelihood method may not be applicable. Consider #>             using birthDeathMCMC() function, which avoids this issue.  #> Warning in FUN(X[[i]], ...): External to internal lengths ratio is less than or equal to 3, #>             which means max. likelihood method may not be applicable. Consider #>             using birthDeathMCMC() function, which avoids this issue.  #> Warning in FUN(X[[i]], ...): External to internal lengths ratio is less than or equal to 3, #>             which means max. likelihood method may not be applicable. Consider #>             using birthDeathMCMC() function, which avoids this issue.  #> Warning in FUN(X[[i]], ...): External to internal lengths ratio is less than or equal to 3, #>             which means max. likelihood method may not be applicable. Consider #>             using birthDeathMCMC() function, which avoids this issue.  #> Warning in FUN(X[[i]], ...): External to internal lengths ratio is less than or equal to 3, #>             which means max. likelihood method may not be applicable. Consider #>             using birthDeathMCMC() function, which avoids this issue.  #> Warning in FUN(X[[i]], ...): External to internal lengths ratio is less than or equal to 3, #>             which means max. likelihood method may not be applicable. Consider #>             using birthDeathMCMC() function, which avoids this issue.  #> Warning in FUN(X[[i]], ...): External to internal lengths ratio is less than or equal to 3, #>             which means max. likelihood method may not be applicable. Consider #>             using birthDeathMCMC() function, which avoids this issue.  #> Warning in FUN(X[[i]], ...): External to internal lengths ratio is less than or equal to 3, #>             which means max. likelihood method may not be applicable. Consider #>             using birthDeathMCMC() function, which avoids this issue.  #> Warning in FUN(X[[i]], ...): External to internal lengths ratio is less than or equal to 3, #>             which means max. likelihood method may not be applicable. Consider #>             using birthDeathMCMC() function, which avoids this issue.  #> Warning in FUN(X[[i]], ...): External to internal lengths ratio is less than or equal to 3, #>             which means max. likelihood method may not be applicable. Consider #>             using birthDeathMCMC() function, which avoids this issue.  #> Warning in FUN(X[[i]], ...): External to internal lengths ratio is less than or equal to 3, #>             which means max. likelihood method may not be applicable. Consider #>             using birthDeathMCMC() function, which avoids this issue.  #> Warning in FUN(X[[i]], ...): External to internal lengths ratio is less than or equal to 3, #>             which means max. likelihood method may not be applicable. Consider #>             using birthDeathMCMC() function, which avoids this issue.  #> Warning in FUN(X[[i]], ...): External to internal lengths ratio is less than or equal to 3, #>             which means max. likelihood method may not be applicable. Consider #>             using birthDeathMCMC() function, which avoids this issue.  #> Warning in FUN(X[[i]], ...): External to internal lengths ratio is less than or equal to 3, #>             which means max. likelihood method may not be applicable. Consider #>             using birthDeathMCMC() function, which avoids this issue.  #> Warning in FUN(X[[i]], ...): External to internal lengths ratio is less than or equal to 3, #>             which means max. likelihood method may not be applicable. Consider #>             using birthDeathMCMC() function, which avoids this issue. lengths_vary_r <- suppressWarnings(internalLengths(vary_r_trees)) # Calculate error in lengths, adding columns lengths_vary_r$ground_truth <- r_vec lengths_vary_r$percent_error <- 100 * (lengths_vary_r$estimate - lengths_vary_r$ground_truth) / lengths_vary_r$ground_truth  # Do the same for maxLike maxLike_vary_r$ground_truth <- r_vec maxLike_vary_r$percent_error <- 100 * (maxLike_vary_r$estimate - maxLike_vary_r$ground_truth) / maxLike_vary_r$ground_truth  # Combine for ggplot formatting results_vary_r <- rbind(lengths_vary_r, maxLike_vary_r)  # Plot, adding a vertical line at 0 because that's the error free estimate ggplot(results_vary_r) +   geom_density(aes(x = percent_error, color = method), linewidth = 1.5) +   geom_vline(xintercept = 0) +   theme_bw() +   xlim(-100, 300) +   theme(     axis.text.y = element_blank(), axis.ticks.y = element_blank(),     legend.title = element_blank()   ) +   xlab(\"Estimate percent error\") +   ylab(\"Density\") +   scale_color_manual(labels = c(\"Internal lengths\", \"Max. likelihood\"), values = c(\"black\", \"#009E73\")) # Cut those trees with ratio > 3 results_vary_r_cut <- results_vary_r[results_vary_r$extIntRatio >= 3, ]  # How many did we cut print((nrow(results_vary_r) - nrow(results_vary_r_cut)) / 2) #> [1] 24  # Plot, adding a vertical line at 0 because that's the error free estimate ggplot(results_vary_r_cut) +   geom_density(aes(x = percent_error, color = method), linewidth = 1.5) +   geom_vline(xintercept = 0) +   theme_bw() +   xlim(-100, 300) +   theme(     axis.text.y = element_blank(), axis.ticks.y = element_blank(),     legend.title = element_blank()   ) +   xlab(\"Estimate percent error\") +   ylab(\"Density\") +   scale_color_manual(labels = c(\"Internal lengths\", \"Max. likelihood\"), values = c(\"black\", \"#009E73\"))"},{"path":"https://bdj34.github.io/cloneRate/articles/reproduce-simResults.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Reproduce simulation results","text":"method simulating trees direct result work Amaury Lambert following paper. mathematical methods estimating growth rates build large part work, linked : Lambert, 2018 ’s final link paper details methods data analysis. aren’t many colors vignette, tried use colorblind friendly colors, specifically pulling colors palette designed Bang Wong available .","code":""},{"path":"https://bdj34.github.io/cloneRate/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Brian Johnson. Maintainer, author. Yubo Shuai. Author. Jason Schweinsberg. Author. Kit Curtius. Author.","code":""},{"path":"https://bdj34.github.io/cloneRate/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Johnson, B., Shuai, Y., Schweinsberg, J., Curtius, K. Estimating single cell clonal dynamics human blood     using coalescent theory. 2023.","code":"@Article{,   title = {Estimating single cell clonal dynamics in human blood using coalescent theory},   author = {Brian Johnson and Yubo Shuai and Jason Schweinsberg and Kit Curtius},   journal = {NA},   year = {2023},   url = {NA}, }"},{"path":"https://bdj34.github.io/cloneRate/index.html","id":"clonerate-","dir":"","previous_headings":"","what":"Estimate growth rates from phylogenetic trees","title":"Estimate growth rates from phylogenetic trees","text":"goal cloneRate provide easily accessible methods estimating growth rate clones. input either ultrametric phylogenetic tree edge lengths corresponding time, non-ultrametric phylogenetic tree edge lengths corresponding mutation counts. package provides internal lengths maximum likelihood methods ultrametric trees shared mutations method mutation-based trees, recent preprint Estimating single cell clonal dynamics human blood using coalescent theory. bonus, provide fast way simulate coalescent (tree) sample birth-death branching process. direct result Amaury Lambert’s work, use fast simulation technique validate growth rate estimates.","code":""},{"path":"https://bdj34.github.io/cloneRate/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Estimate growth rates from phylogenetic trees","text":"can install development version cloneRate GitHub : basic tutorial vignettes, also use several packages, can installed CRAN. listed packages suggest, running following command install along vignettes. Alternatively, can install manually:","code":"# Install devtools if you don't have it already install.packages(setdiff(\"devtools\", rownames(installed.packages())))  # Install  devtools::install_github(\"bdj34/cloneRate\") devtools::install_github(\"bdj34/cloneRate\", build_vignettes = TRUE, dependencies = TRUE) install.packages(setdiff(c(\"ggplot2\", \"ggsurvfit\", \"survival\", \"car\"), rownames(installed.packages())))"},{"path":"https://bdj34.github.io/cloneRate/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Estimate growth rates from phylogenetic trees","text":"’ll walk simulating single tree plotting , apply growth rate methods.","code":""},{"path":"https://bdj34.github.io/cloneRate/index.html","id":"simulate-data","dir":"","previous_headings":"Example","what":"Simulate data","title":"Estimate growth rates from phylogenetic trees","text":"can simulate sample size n birth-death tree follows: Now simulated tree, let’s plot :","code":"library(cloneRate) library(ape) library(ggplot2)  # Generate a sampled tree with 100 tips from a 20 year birth-death process with birth rate a=1 and death rate b=0.5 tree <- simUltra(a = 1, b = 0.5, cloneAge = 40, n = 100) # Plot, then add scale and title plot.phylo(tree,   direction = \"downwards\",   show.tip.label = FALSE, edge.width = 2 ) axisPhylo(side = 2, backward = FALSE, las = 1) title(main = \"Simulated ultrametric tree\", ylab = \"Time (years)\")"},{"path":"https://bdj34.github.io/cloneRate/index.html","id":"estimate-growth-rate-of-one-tree","dir":"","previous_headings":"Example","what":"Estimate growth rate of one tree","title":"Estimate growth rates from phylogenetic trees","text":"can use tree input methods growth rate estimation: ’re simulating new tree time, estimate change run, don’t worried results don’t match exactly.","code":"# Estimate the growth rate r=a-b=0.5 using maximum likelihood maxLike.df <- maxLikelihood(tree) print(paste0(\"Max. likelihood estimate = \", round(maxLike.df$estimate, 3))) #> [1] \"Max. likelihood estimate = 0.501\"  # Estimate the growth rate r=a-b=0.5 using internal lengths intLengths.df <- internalLengths(tree) print(paste0(\"Internal lengths estimate = \", round(intLengths.df$estimate, 3))) #> [1] \"Internal lengths estimate = 0.488\""},{"path":"https://bdj34.github.io/cloneRate/index.html","id":"estimate-growth-rate-of-many-trees","dir":"","previous_headings":"Example","what":"Estimate growth rate of many trees","title":"Estimate growth rates from phylogenetic trees","text":"paper, use simulated trees test growth rate estimates. example, let’s load simulated data comes package, exampleUltraTrees 100 ultrametric trees. “metadata” data.frame find ground truth growth rate, case 1. Let’s apply methods 100 trees. Notice functions maxLikelihood() internalLengths() can take input either single tree list trees. Either way, output data.frame containing results. Now 100 estimates 100 different trees 2 different methods, let’s plot distributions  Finally, let’s compute root mean square error (RMSE) estimates. expect maximum likelihood perform best RMSE, 100 relatively small sample size anything happen… expected, maximum likelihood performs best. Note may change regenerate data. details, see cloneRate website vignettes:","code":"# Here we are applying two methods to all of the ultrametric trees resultsUltraMaxLike <- maxLikelihood(exampleUltraTrees) resultsUltraLengths <- internalLengths(exampleUltraTrees) # Combine all into one df for plotting. This works because the columns are the same resultsCombined <- rbind(resultsUltraMaxLike, resultsUltraLengths)  # Plot, adding a vertical line at r=1 because that's the true growth rate ggplot(resultsCombined) +   geom_density(aes(x = estimate, color = method), linewidth = 1.5) +   geom_vline(xintercept = exampleUltraTrees[[1]]$metadata$r) +   theme_bw() +   theme(     axis.text.y = element_blank(), axis.ticks.y = element_blank(),     legend.title = element_blank()   ) +   xlab(\"Net growth rate estimate (r)\") +   ylab(\"Density\") +   scale_color_manual(labels = c(\"Internal lengths\", \"Max. likelihood\"), values = c(\"black\", \"#009E73\")) # Calculate the RMSE groundTruth <- exampleUltraTrees[[1]]$metadata$r[1] rmse <- unlist(lapply(   split(resultsCombined, resultsCombined$method),   function(x) {     sqrt(sum((x$estimate - groundTruth)^2) / length(x$estimate))   } ))  print(rmse) #>    lengths    maxLike  #> 0.09823356 0.09333771 vignette(\"cloneRate-dataAnalysis\", package = \"cloneRate\") vignette(\"cloneRate-simulate\", package = \"cloneRate\")"},{"path":"https://bdj34.github.io/cloneRate/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Estimate growth rates from phylogenetic trees","text":"package comes 42 clones annotated four distinct publications, ones use analysis. Note three clones profiled two different timepoints, meaning 39 unique clones. papers generate data : Williams et al. 2022 Mitchell et al. 2022 Fabre et al. 2022 Van Egeren et al. 2021 mathematical basis estimates detailed full paper. Simulating birth-death trees direct result work Amaury Lambert : Lambert, 2018","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/birthDeathMCMC.html","id":null,"dir":"Reference","previous_headings":"","what":"Growth rate estimate using MCMC — birthDeathMCMC","title":"Growth rate estimate using MCMC — birthDeathMCMC","text":"Uses Rstan U-turn sampler approximate growth rate using likelihood Stadler 2009 \"incomplete sampling birth–death models connections sampling-based coalescent\"","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/birthDeathMCMC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Growth rate estimate using MCMC — birthDeathMCMC","text":"","code":"birthDeathMCMC(   tree,   maxGrowthRate = 4,   alpha = 0.05,   verbose = TRUE,   nChains = 3,   nCores = 1,   chainLength = 2000 )"},{"path":"https://bdj34.github.io/cloneRate/reference/birthDeathMCMC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Growth rate estimate using MCMC — birthDeathMCMC","text":"tree ultrametric tree subset include clone interest. Alternatively, list several trees. maxGrowthRate Sets upper bound birth rate. Default 4 depend nature data alpha Used calculation confidence intervals. 1-alpha confidence intervals used default alpha = 0.05 (95 percent confidence intervals) verbose TRUE FALSE, Rstan MCMC intermediate output progress printed? nChains Number chains run MCMC. Default 3 nCores Number cores perform MCMC. Default 1, chains can run parallel chainLength Number iterations chain MCMC. Default 2000, increase stan tells ","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/birthDeathMCMC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Growth rate estimate using MCMC — birthDeathMCMC","text":"dataframe including net growth rate estimate, confidence intervals, important details (clone age estimate, runtime, n, etc.)","code":""},{"path":[]},{"path":"https://bdj34.github.io/cloneRate/reference/birthDeathMCMC.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Growth rate estimate using MCMC — birthDeathMCMC","text":"","code":"df <- birthDeathMCMC(cloneRate::exampleUltraTrees[[1]]) #>  #> CHECKING DATA AND PREPROCESSING FOR MODEL '074955cb23b8ac2bef05bf679ec41d0b' NOW. #>  #> COMPILING MODEL '074955cb23b8ac2bef05bf679ec41d0b' NOW. #>  #> STARTING SAMPLER FOR MODEL '074955cb23b8ac2bef05bf679ec41d0b' NOW. #>  #> SAMPLING FOR MODEL '074955cb23b8ac2bef05bf679ec41d0b' NOW (CHAIN 1). #> Chain 1:  #> Chain 1: Gradient evaluation took 0.00012 seconds #> Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 1.2 seconds. #> Chain 1: Adjust your expectations accordingly! #> Chain 1:  #> Chain 1:  #> Chain 1: Iteration:    1 / 2000 [  0%]  (Warmup) #> Chain 1: Iteration:  200 / 2000 [ 10%]  (Warmup) #> Chain 1: Iteration:  400 / 2000 [ 20%]  (Warmup) #> Chain 1: Iteration:  600 / 2000 [ 30%]  (Warmup) #> Chain 1: Iteration:  800 / 2000 [ 40%]  (Warmup) #> Chain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup) #> Chain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling) #> Chain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling) #> Chain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling) #> Chain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling) #> Chain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling) #> Chain 1: Iteration: 2000 / 2000 [100%]  (Sampling) #> Chain 1:  #> Chain 1:  Elapsed Time: 6.15514 seconds (Warm-up) #> Chain 1:                7.64648 seconds (Sampling) #> Chain 1:                13.8016 seconds (Total) #> Chain 1:  #>  #> SAMPLING FOR MODEL '074955cb23b8ac2bef05bf679ec41d0b' NOW (CHAIN 2). #> Chain 2:  #> Chain 2: Gradient evaluation took 6e-05 seconds #> Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 0.6 seconds. #> Chain 2: Adjust your expectations accordingly! #> Chain 2:  #> Chain 2:  #> Chain 2: Iteration:    1 / 2000 [  0%]  (Warmup) #> Chain 2: Iteration:  200 / 2000 [ 10%]  (Warmup) #> Chain 2: Iteration:  400 / 2000 [ 20%]  (Warmup) #> Chain 2: Iteration:  600 / 2000 [ 30%]  (Warmup) #> Chain 2: Iteration:  800 / 2000 [ 40%]  (Warmup) #> Chain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup) #> Chain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling) #> Chain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling) #> Chain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling) #> Chain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling) #> Chain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling) #> Chain 2: Iteration: 2000 / 2000 [100%]  (Sampling) #> Chain 2:  #> Chain 2:  Elapsed Time: 6.78141 seconds (Warm-up) #> Chain 2:                6.45597 seconds (Sampling) #> Chain 2:                13.2374 seconds (Total) #> Chain 2:  #>  #> SAMPLING FOR MODEL '074955cb23b8ac2bef05bf679ec41d0b' NOW (CHAIN 3). #> Chain 3:  #> Chain 3: Gradient evaluation took 5.7e-05 seconds #> Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 0.57 seconds. #> Chain 3: Adjust your expectations accordingly! #> Chain 3:  #> Chain 3:  #> Chain 3: Iteration:    1 / 2000 [  0%]  (Warmup) #> Chain 3: Iteration:  200 / 2000 [ 10%]  (Warmup) #> Chain 3: Iteration:  400 / 2000 [ 20%]  (Warmup) #> Chain 3: Iteration:  600 / 2000 [ 30%]  (Warmup) #> Chain 3: Iteration:  800 / 2000 [ 40%]  (Warmup) #> Chain 3: Iteration: 1000 / 2000 [ 50%]  (Warmup) #> Chain 3: Iteration: 1001 / 2000 [ 50%]  (Sampling) #> Chain 3: Iteration: 1200 / 2000 [ 60%]  (Sampling) #> Chain 3: Iteration: 1400 / 2000 [ 70%]  (Sampling) #> Chain 3: Iteration: 1600 / 2000 [ 80%]  (Sampling) #> Chain 3: Iteration: 1800 / 2000 [ 90%]  (Sampling) #> Chain 3: Iteration: 2000 / 2000 [100%]  (Sampling) #> Chain 3:  #> Chain 3:  Elapsed Time: 6.46037 seconds (Warm-up) #> Chain 3:                7.32453 seconds (Sampling) #> Chain 3:                13.7849 seconds (Total) #> Chain 3:"},{"path":"https://bdj34.github.io/cloneRate/reference/coal_to_tree.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate tree from coalescence times — coal_to_tree","title":"Generate tree from coalescence times — coal_to_tree","text":"generates tree vector coalescence times randomly merging lineages.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/coal_to_tree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate tree from coalescence times — coal_to_tree","text":"","code":"coal_to_tree(coal_times)"},{"path":"https://bdj34.github.io/cloneRate/reference/coal_to_tree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate tree from coalescence times — coal_to_tree","text":"coal_times numeric vector coalescence times","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/coal_to_tree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate tree from coalescence times — coal_to_tree","text":"ape object class \"phylo\" representing ultrametric phylogenetic tree edge lengths units time.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/coal_to_tree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate tree from coalescence times — coal_to_tree","text":"","code":"# Generate an ape phylo tree with n tips from a vector of n-1 coalescence times randomCoalTimes <- c(9.3, 7.8, 10.15, 11.23, 9.4, 8.8, 10.01, 13) tree <- coal_to_tree(randomCoalTimes)"},{"path":"https://bdj34.github.io/cloneRate/reference/exampleMutTrees.html","id":null,"dir":"Reference","previous_headings":"","what":"Example mutation tree data — exampleMutTrees","title":"Example mutation tree data — exampleMutTrees","text":"Set 100 mutation based trees reconstructed distribution sample n=100 tips. trees net growth rate 1 birth rates 1 2 (sampled uniform distribution). Death rates equal chosen birth rate minus 1. Tree reconstruction uses exact distribution coalescence times described \"coalescent sample binary branching process\", Lambert ., Theor. Pop. Bio. 2018. Tree construction formatting uses ape R package ape::rcoal(). change edge lengths time-based mutation-based drawing poisson distribution mean equal edge length (units time) multiplied mutation rate, nu, drawn uniform distribution 10 20 mutations per year.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/exampleMutTrees.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example mutation tree data — exampleMutTrees","text":"","code":"data(exampleMutTrees)"},{"path":"https://bdj34.github.io/cloneRate/reference/exampleMutTrees.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example mutation tree data — exampleMutTrees","text":"list objects class phylo edge matrix edge connections reconstruct tree. edge.length numeric vector branch lengths connections edge matrix. Units mutations. tip.label character vector containing  (arbitrary case) labels 100 tips/samples tree. Nnode Integer number internal nodes tree params data.frame containing info params used generate tree","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/exampleMutTrees.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Example mutation tree data — exampleMutTrees","text":"data set created cloneRate package using coalescent theory approaches described \"coalescent sample binary branching process\", Lambert ., Theor. Pop. Bio. 2018.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/exampleMutTrees.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Example mutation tree data — exampleMutTrees","text":"","code":"# Plot first of 100 trees ape::plot.phylo(cloneRate::exampleMutTrees[[1]],   direction = \"downwards\", show.tip.label = FALSE )"},{"path":"https://bdj34.github.io/cloneRate/reference/exampleUltraTrees.html","id":null,"dir":"Reference","previous_headings":"","what":"Example ultrametric tree data — exampleUltraTrees","title":"Example ultrametric tree data — exampleUltraTrees","text":"Set 100 time-based ultrametric trees reconstructed distribution sample n=100 tips. trees net growth rate 1 birth rates 1 2 (sampled uniform distribution). Death rates equal chosen birth rate minus 1. Tree reconstruction uses exact distribution coalescence times described \"coalescent sample binary branching process\", Lambert ., Theor. Pop. Bio. 2018. Tree construction formatting uses ape R package ape::rcoal().","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/exampleUltraTrees.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example ultrametric tree data — exampleUltraTrees","text":"","code":"data(exampleUltraTrees)"},{"path":"https://bdj34.github.io/cloneRate/reference/exampleUltraTrees.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example ultrametric tree data — exampleUltraTrees","text":"list objects class phylo edge matrix edge connections reconstruct tree. edge.length numeric vector branch lengths connections edge matrix. Units years. tip.label character vector containing  (arbitrary case) labels 100 tips/samples tree. Nnode Integer number internal nodes tree params data.frame containing info params used generate tree","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/exampleUltraTrees.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Example ultrametric tree data — exampleUltraTrees","text":"data set created cloneRate package using coalescent theory approaches described \"coalescent sample binary branching process\", Lambert ., Theor. Pop. Bio. 2018.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/exampleUltraTrees.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Example ultrametric tree data — exampleUltraTrees","text":"","code":"# Plot first of 100 trees ape::plot.phylo(cloneRate::exampleUltraTrees[[1]],   direction = \"downwards\", show.tip.label = FALSE )"},{"path":"https://bdj34.github.io/cloneRate/reference/inputCheck.html","id":null,"dir":"Reference","previous_headings":"","what":"Check the inputs to growth rate functions — inputCheck","title":"Check the inputs to growth rate functions — inputCheck","text":"Check validity inputs growth rate fns, making sure tree ultrametric ape phylo object reasonable alpha","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/inputCheck.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check the inputs to growth rate functions — inputCheck","text":"","code":"inputCheck(tree, alpha)"},{"path":"https://bdj34.github.io/cloneRate/reference/inputCheck.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check the inputs to growth rate functions — inputCheck","text":"tree ape tree subset include clone interest alpha Used calculation confidence intervals. 1-alpha confidence intervals used default alpha = 0.05 (95 percent confidence intervals)","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/internalLengths.html","id":null,"dir":"Reference","previous_headings":"","what":"Growth rate estimate using the sum of internal lengths — internalLengths","title":"Growth rate estimate using the sum of internal lengths — internalLengths","text":"internalLengths() provides estimate net growth rate clone confidence bounds, using internal lengths method.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/internalLengths.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Growth rate estimate using the sum of internal lengths — internalLengths","text":"","code":"internalLengths(tree, alpha = 0.05)"},{"path":"https://bdj34.github.io/cloneRate/reference/internalLengths.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Growth rate estimate using the sum of internal lengths — internalLengths","text":"tree ultrametric tree subset include clone interest. Alternatively, list several trees. alpha Used calculation confidence intervals. 1-alpha confidence intervals used default alpha = 0.05 (95 percent confidence intervals)","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/internalLengths.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Growth rate estimate using the sum of internal lengths — internalLengths","text":"dataframe including net growth rate estimate, sum internal lengths important details (clone age estimate, runtime, n, etc.)","code":""},{"path":[]},{"path":"https://bdj34.github.io/cloneRate/reference/internalLengths.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Growth rate estimate using the sum of internal lengths — internalLengths","text":"","code":"internalLengths(cloneRate::exampleUltraTrees[[1]]) #>   lowerBound estimate upperBound cloneAgeEstimate sumInternalLengths #> 1  0.9545856  1.18729   1.419995               20            84.2254 #>   sumExternalLengths extIntRatio   n alpha runtime_s  method #> 1           1193.354    14.16858 100  0.05     0.005 lengths"},{"path":"https://bdj34.github.io/cloneRate/reference/longitudinalData.html","id":null,"dir":"Reference","previous_headings":"","what":"Longitudinal validation data — longitudinalData","title":"Longitudinal validation data — longitudinalData","text":"three individuals clonal expansions can estimated using methods, longitudinal data orthogonally validate estimates, provided .","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/longitudinalData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Longitudinal validation data — longitudinalData","text":"","code":"longitudinalData"},{"path":"https://bdj34.github.io/cloneRate/reference/longitudinalData.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Longitudinal validation data — longitudinalData","text":"data.frame containing information needed Sample.ID individual's ID Age Individual's age various sampling times VAF variant allele frequency various sampling times clone interest Gene Gene genes mutation identifies clone Protein Protein affected mutation cellType type cells used sequencing cloneName name use clone match single cell data","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/longitudinalData.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Longitudinal validation data — longitudinalData","text":"datasets generated annotated : Williams et al. 2022 Fabre et al. 2022","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/longitudinalData.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Longitudinal validation data — longitudinalData","text":"","code":"library(ggplot2) # Plot longitudinal data from PD9478 ggplot(longitudinalData[longitudinalData$Sample.ID == \"PD9478\", ]) +   geom_point(aes(x = Age, y = VAF))"},{"path":"https://bdj34.github.io/cloneRate/reference/maxLikelihood.html","id":null,"dir":"Reference","previous_headings":"","what":"Growth rate estimate using Maximum Likelihood — maxLikelihood","title":"Growth rate estimate using Maximum Likelihood — maxLikelihood","text":"Uses approximation coalescence times H_i equal +b*U_i find b. b equal 1/r, r net growth rate.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/maxLikelihood.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Growth rate estimate using Maximum Likelihood — maxLikelihood","text":"","code":"maxLikelihood(tree, alpha = 0.05)"},{"path":"https://bdj34.github.io/cloneRate/reference/maxLikelihood.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Growth rate estimate using Maximum Likelihood — maxLikelihood","text":"tree ultrametric tree subset include clone interest. Alternatively, list several trees. alpha Used calculation confidence intervals. 1-alpha confidence intervals used default alpha = 0.05 (95 percent confidence intervals)","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/maxLikelihood.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Growth rate estimate using Maximum Likelihood — maxLikelihood","text":"dataframe including net growth rate estimate, confidence intervals, important details (clone age estimate, runtime, n, etc.)","code":""},{"path":[]},{"path":"https://bdj34.github.io/cloneRate/reference/maxLikelihood.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Growth rate estimate using Maximum Likelihood — maxLikelihood","text":"","code":"df <- maxLikelihood(cloneRate::exampleUltraTrees[[1]])"},{"path":"https://bdj34.github.io/cloneRate/reference/realCloneData.html","id":null,"dir":"Reference","previous_headings":"","what":"Real clone data from human blood — realCloneData","title":"Real clone data from human blood — realCloneData","text":"42 clones (39 distinct) 32 individual donors, 13 diagnosis Myeloproliferative Neoplasm","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/realCloneData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Real clone data from human blood — realCloneData","text":"","code":"data(realCloneData)"},{"path":"https://bdj34.github.io/cloneRate/reference/realCloneData.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Real clone data from human blood — realCloneData","text":"list containing one list full ultrametric trees 30 32 individual donors (two Van Egeren included), one list containing 42 clone trees.three cases, two timepoints clone, separate phylo objects. list contains tree class phylo object. See ape package documentation details class phylo objects. Names phylo object (tree) list matches naming used sources also includes driver, age, clone number.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/realCloneData.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Real clone data from human blood — realCloneData","text":"https://pubmed.ncbi.nlm.nih.gov/35058638/ https://pubmed.ncbi.nlm.nih.gov/35650442/ https://pubmed.ncbi.nlm.nih.gov/35650444/ https://pubmed.ncbi.nlm.nih.gov/33621486/","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/realCloneData.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Real clone data from human blood — realCloneData","text":"datasets generated annotated : Williams et al. 2022 Mitchell et al. 2022 Fabre et al. 2022 Van Egeren et al. 2021","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/realCloneData.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Real clone data from human blood — realCloneData","text":"","code":"# Plot full reconstructed tree from donor PD34493 ape::plot.phylo(cloneRate::realCloneData[[\"fullTrees\"]][[\"PD34493\"]],   direction = \"downwards\", show.tip.label = FALSE )"},{"path":"https://bdj34.github.io/cloneRate/reference/sharedMuts.html","id":null,"dir":"Reference","previous_headings":"","what":"Growth rate estimate using the sum of shared mutations assuming a mutation tree — sharedMuts","title":"Growth rate estimate using the sum of shared mutations assuming a mutation tree — sharedMuts","text":"sharedMuts() provides estimate net growth rate clone confidence bounds, using shared mutations method.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/sharedMuts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Growth rate estimate using the sum of shared mutations assuming a mutation tree — sharedMuts","text":"","code":"sharedMuts(tree, nu = NULL, alpha = 0.05)"},{"path":"https://bdj34.github.io/cloneRate/reference/sharedMuts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Growth rate estimate using the sum of shared mutations assuming a mutation tree — sharedMuts","text":"tree non-ultrametric ape tree subset include clone interest nu mutation rate. none given, sharedMuts() first look nu column metadata data.frame tree, look nu tree . throw error nu given found. alpha Used calculation confidence intervals. 1-alpha confidence intervals used default alpha = 0.05 (95 percent confidence intervals)","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/sharedMuts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Growth rate estimate using the sum of shared mutations assuming a mutation tree — sharedMuts","text":"dataframe including net growth rate estimate, sum internal lengths important details (clone age estimate, runtime, n, etc.)","code":""},{"path":[]},{"path":"https://bdj34.github.io/cloneRate/reference/sharedMuts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Growth rate estimate using the sum of shared mutations assuming a mutation tree — sharedMuts","text":"","code":"sharedMuts(cloneRate::exampleMutTrees[[1]]) #>   lowerBound estimate upperBound       nu cloneAgeEstimate sharedMutations #> 1  0.9236845  1.16662   1.409555 18.67758         20.29171            1601 #>   privateMutations extIntRatio   n alpha runtime_s     method #> 1            16944    10.58339 100  0.05     0.006 sharedMuts"},{"path":"https://bdj34.github.io/cloneRate/reference/simMut.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate mutation-based birth and death branching trees — simMut","title":"Simulate mutation-based birth and death branching trees — simMut","text":"Generates sampled tree (list many sampled trees) supercritial (birth rate > death rate) birth death branching process according coalescent point process described \"Lambert, . coalescent sample binary branching process. (2018).\" Edge lengths units mutations, assuming poissonian mutation accumulation. Essentially wrapper combining simUltra() ultra2mut() functions one step.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/simMut.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate mutation-based birth and death branching trees — simMut","text":"","code":"simMut(   a,   b,   cloneAge,   n,   nu,   nTrees = 1,   precBits = 1000,   addStem = FALSE,   nCores = 1 )"},{"path":"https://bdj34.github.io/cloneRate/reference/simMut.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate mutation-based birth and death branching trees — simMut","text":"Birth rate b Death rate cloneAge Clone age. Make sure time units birth death rates n Number samples/tips tree returned nu Mutation rate units mutations per unit time. Make sure time units consistent birth death rates cloneAge nTrees Integer indicating number trees generate. Default 1. precBits Rmpfr param handling high precision numbers. Needed draw coalescence times. addStem Boolean indicating whether add stem tree preceding first split/coalescence nCores Integer indicating number cores use parallel pkg installed. Default 1.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/simMut.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate mutation-based birth and death branching trees — simMut","text":"ape object class \"phylo\" representing ultrametric phylogenetic tree edge lengths units time. Tree metadata located 'metadata' data.frame included \"phylo\" object. 'nTrees' param greater 1, simUltra returns list objects objects class \"phylo\".","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/simMut.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate mutation-based birth and death branching trees — simMut","text":"","code":"# Generate a single mutation-based tree with a specified mutation rate tree <- simMut(a = 1, b = 0.5, cloneAge = 40, n = 50, nu = 10)  # Generate a list of mutation-based trees with a range of mutation rates tree_list <- simMut(   a = 1, b = 0.5, cloneAge = 40, n = 50,   nu = stats::runif(n = 5, min = 10, max = 20), nTrees = 5 )"},{"path":"https://bdj34.github.io/cloneRate/reference/simUltra.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate ultrametric birth and death branching trees — simUltra","title":"Simulate ultrametric birth and death branching trees — simUltra","text":"Generates sampled tree (list many sampled trees) supercritial (birth rate > death rate) birth death branching process according coalescent point process described \"Lambert, . coalescent sample binary branching process. (2018).\"","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/simUltra.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate ultrametric birth and death branching trees — simUltra","text":"","code":"simUltra(   a,   b,   cloneAge,   n,   nTrees = 1,   precBits = 1000,   addStem = FALSE,   nCores = 1 )"},{"path":"https://bdj34.github.io/cloneRate/reference/simUltra.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate ultrametric birth and death branching trees — simUltra","text":"Birth rate vector birth rates length 'nTrees' b Death rate vector death rates length 'nTrees' cloneAge Clone age vector clone ages length 'nTrees'. Make sure time units birth death rates n Number samples/tips tree returned. Can vector length 'nTrees' well. nTrees Integer indicating number trees generate. Default 1 precBits Rmpfr param handling high precision numbers. Needed drawing coalescence times. Can vector length 'nTrees', though recommended addStem Boolean indicating whether add stem tree preceding first split/coalescence. Can also vector length 'nTrees' nCores Integer indicating number cores use parallel pkg installed. Default 1.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/simUltra.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate ultrametric birth and death branching trees — simUltra","text":"ape object class \"phylo\" representing ultrametric phylogenetic tree edge lengths units time. Tree metadata located 'metadata' data.frame included \"phylo\" object. 'nTrees' param greater 1, simUltra returns list objects objects class \"phylo\".","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/simUltra.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate ultrametric birth and death branching trees — simUltra","text":"","code":"# Generate a single tree tree <- simUltra(a = 1, b = 0.5, cloneAge = 20, n = 50)  # Generate a list of trees tree_list <- simUltra(a = 1, b = 0.5, cloneAge = 20, n = 50, nTrees = 5)"},{"path":"https://bdj34.github.io/cloneRate/reference/siteFrequency.html","id":null,"dir":"Reference","previous_headings":"","what":"Get site frequency spectrum of a tree — siteFrequency","title":"Get site frequency spectrum of a tree — siteFrequency","text":"siteFrequency() returns data.frame frequency units time mutations, well normalized frequency.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/siteFrequency.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get site frequency spectrum of a tree — siteFrequency","text":"","code":"siteFrequency(tree, includeStem = F)"},{"path":"https://bdj34.github.io/cloneRate/reference/siteFrequency.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get site frequency spectrum of a tree — siteFrequency","text":"tree ultrametric mutation-based tree subset include clone interest. Alternatively, list several trees. includeStem Boolean indicating whether count stem tree contributing site frequency distribution. Default FALSE.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/siteFrequency.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get site frequency spectrum of a tree — siteFrequency","text":"data.frame three columns: number descendant cells, site frequency units time mutations, normalized site frequency. list trees input, output list data.frames.","code":""},{"path":[]},{"path":"https://bdj34.github.io/cloneRate/reference/siteFrequency.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get site frequency spectrum of a tree — siteFrequency","text":"","code":"# Get site frequency of a single tree example.df <- siteFrequency(exampleUltraTrees[[1]])  # Get site frequency of a list of trees example.list <- siteFrequency(exampleMutTrees)"},{"path":"https://bdj34.github.io/cloneRate/reference/ultra2mut.html","id":null,"dir":"Reference","previous_headings":"","what":"Add poissonian mutations to an ultrametric tree(s) — ultra2mut","title":"Add poissonian mutations to an ultrametric tree(s) — ultra2mut","text":"Takes ultrametric tree class \"phylo\" (list trees) draws new edge lengths units mutations, mean new edge length equal old edge length multiplied mutation rate. Mutation rate can set drawn uniform distribution.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/ultra2mut.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add poissonian mutations to an ultrametric tree(s) — ultra2mut","text":"","code":"ultra2mut(tree, nu)"},{"path":"https://bdj34.github.io/cloneRate/reference/ultra2mut.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add poissonian mutations to an ultrametric tree(s) — ultra2mut","text":"tree single tree list trees class \"phylo\", edge lengths units time nu Mutation rate units mutations per unit time. Can also vector mutation rates length equal number input trees. Make sure time units consistent nu tree$edge.length","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/ultra2mut.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add poissonian mutations to an ultrametric tree(s) — ultra2mut","text":"ape object class \"phylo\" representing phylogenetic tree edge lengths units mutations. Value mutation rate added 'metadata' data.frame output tree data.frame exists input tree. Otherwise, mutation rate value added \"phylo\" object directly. input list trees, ultra2mut() return list \"phylo\" objects.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/ultra2mut.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add poissonian mutations to an ultrametric tree(s) — ultra2mut","text":"","code":"# Convert the time-based, ultrametric example trees into mutation-based trees mutTrees <- ultra2mut(exampleUltraTrees,   nu = stats::runif(n = length(exampleUltraTrees), min = 10, max = 20) )"},{"path":[]},{"path":"https://bdj34.github.io/cloneRate/news/index.html","id":"add-birth-death-mcmc-0-1-0","dir":"Changelog","previous_headings":"","what":"Add birth-death MCMC","title":"cloneRate 0.1.0","text":"Add birth death MCMC targeting likelihood equation 5 Stadler 2009 “incomplete sampling birth–death models connections sampling-based coalescent” Implements MCMC using rstan package, now listed suggests","code":""},{"path":"https://bdj34.github.io/cloneRate/news/index.html","id":"clonerate-001","dir":"Changelog","previous_headings":"","what":"cloneRate 0.0.1","title":"cloneRate 0.0.1","text":"Added NEWS.md file track changes package.","code":""}]
