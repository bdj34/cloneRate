[{"path":"https://bdj34.github.io/cloneRate/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 cloneRate authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-dataAnalysis.html","id":"packages","dir":"Articles","previous_headings":"","what":"Packages","title":"cloneRate Analysis of human blood data","text":"First, ’ll load packages want use. help understand data, ’ll want able visualize phylogenetic trees. ggtree package help us , ’s built ggplot2 ’ll use well.","code":"# Load and attach our package cloneRate library(cloneRate)  # Install ggplot2 if necessary, then load and attach it with library() if (!requireNamespace(\"ggplot2\")) {   install.packages(\"ggplot2\") } library(ggplot2)  # Install ggtree if necessary, then load and attach it with library() if (!requireNamespace(\"ggtree\")) {   install.packages(\"ggtree\") } library(ggtree)"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-dataAnalysis.html","id":"real-data","dir":"Articles","previous_headings":"","what":"Real data","title":"cloneRate Analysis of human blood data","text":"First, let’s examine realCloneData, contains necessary data reproduce analysis. two lists contained dataset, one contains full reconstructed tree individual timepoint (named fullTrees), one contains specific clones full trees (named cloneTrees). require clone must least n=10 tips (cells) included cloneTrees. discuss requirement simulation vignette now, let’s split two different variables clarity. Let’s start looking full tree single individual, “PD9478”. individuals study sequenced multiple timepoints, refer ID (“PD9478”) timepoint (“_1”) get specific tree fullTrees.list. case, timepoint timepoint 1, let’s take look full tree “PD9478_1”. data comes work Williams et al., details can found paper, linked .  went simulation vignette, ’ll notice tree looks quite bit different ones simulated. tree, clear example somatic clonal expansion, highlight red. know authors produced data (see Williams et al. Fig. 3 PD9478), sampled cells within clone mutation JAK2 gene DNMT3A gene, known important clonal expansions blood. Let’s look closely clone red see can learn tree.  Now tree clonal expansion looks lot like trees simulate! suggests growth rate cell within clone roughly cells within clone. can now apply methods clone tree shown . see tree ultrametric know ’s time-based, units years, apply internalLengths() maxLikelihood() functions. Unfortunately, don’t ground truth compare working real data. However, individual clone longitudinal sequencing data, can use estimate orthogonal growth rate. ’ll come back end vignette. First, let’s apply analysis clone trees. give list phylo objects, growth rate functions estimate growth rate separately, returning dataframe row telling us result tree. Oof! Looks like error… says two trees input “PD5847_1_clone1” “PD4781_1_clone1” binary branching trees. means one node 2 direct descendants. case, ’s big deal. know trees resconstructed mutation data, just mean picked two divisions happened without mutations occurring two divisions. Let’s plot one can see happens  can see three descendants node 76, identified red circle. see lot places multiple splits (coalescence events) quick succession, place 1 node appears split 3. Well, ’s okay, mutations imperfect way keep track time. saw events one node splits 3, cases node splits 4+, might concerned. case, can move . functions growth rate estimation equipped handle trees like , throw warnings know ’s happening. Let’s continue, applying maxLikelihood() function trees. bad! functions (maxLikelihood() internalLengths()) returns data.frame columns, ’ll walk columns mean : lowerBound, estimate, upperBound: growth rate estimate confidence intervals. default 95% confidence intervals, can adjusted setting alpha parameter function input. cloneAgeEstimate estimate time clone initiation sampling. earliest coalescence time clone tree gives us rough estimate clone age, add \\(1/r\\) (1 divided growth rate estimate) account expected time initiation first surviving division (first coalescence). ’ll discuss later. sumInternalLengths, sumExternalLengths, extintRatio: sum internal edge lengths, external edge lengths, ratio two. use ratio say whether enough time passed use method (see simulation vignette). Fortunately, real data ratio > 3, can apply methods clone trees. n number tips clone tree. case, corresponds number cells sequenced clone. alpha confidence level. use 1-alpha confidence intervals. runtime_s runtime method seconds. method method used, helps want combine data.frames output different methods plotting. names unique name clone corresponding individual ID clone number. individuals Williams paper, individuals sampled multiple timepoints, ID followed “_1”, “_2”, “_3” indicate timepoint. Now growth rates, let’s make sense . look inside cloneTrees.list, realize also metadata. Let’s print two examples, one individual Myeloproliferative Neoplasm (MPN), one without: biological /clinical analysis, important : age tells us individual’s age. know clonal hematopoiesis associated aging. cloneDriver tells us clonal hematopoiesis driver likely leads expansion. diagnosis.age tells us individual diagnosed Myeloproliferative Neoplasm (MPN). individual doesn’t MPN, diagnosis.age NA. malnorm tells us whether individual diagnosed Myeloproliferative Neoplasm (MPN). information already conveyed diagnosis.age, ’s sometimes easier work format. Let’s combine cloneTrees.list metadata one data.frame, can analyze together results running functions. Let’s join data.frames containing metadata results. can use cbind base R know order metadata order results data.frame. can check comparing cloneName_result cloneName_meta columns, () . ’ll go forward analysis using results data.frame, contains estimates maxLikelihood() function. simulation vignette, show maximum likelihood estimate performs best.","code":"summary(cloneRate::realCloneData) #>            Length Class  Mode #> fullTrees  30     -none- list #> cloneTrees 42     -none- list fullTrees.list <- cloneRate::realCloneData$fullTrees cloneTrees.list <- cloneRate::realCloneData$cloneTrees # Plot the full tree from individual PD9478 at timepoint 1 PD9478 <- fullTrees.list$PD9478_1 ggtree(PD9478) + theme_tree2(fgcolor = \"blue\") + geom_hilight(node = 85, fill = \"red\", alpha = .1) + xlab(\"Time (years)\") # Load the red clone from our cloneTrees.list PD9478_subClone <- cloneTrees.list[[\"PD9478_1_clone1\"]]  # Plot the clone tree ggtree(PD9478_subClone) + theme_tree2(fgcolor = \"blue\") + xlab(\"Time (years)\") #+ layout_dendrogram() # Get maximum likelihood and internal lengths estimates print(round(maxLikelihood(PD9478_subClone)$estimate, 3)) #> [1] 0.516 print(round(internalLengths(PD9478_subClone)$estimate, 3)) #> [1] 0.601 # Apply each of our estimates resultsLengths <- internalLengths(cloneTrees.list) #> Warning in FUN(X[[i]], ...): Tree is not binary. Birth-death branching trees should be binary, #>        but tree resonstruction from data may lead to  3+ descendants from #>        a single parent node. Proceed with caution! Input tree has #>       3 nodes directly descending from a single #>        parent node. A binary tree would only have 2 descendant nodes #>        from each parent node. Tree throwing warning is PD5847_1_clone1 #> Warning in FUN(X[[i]], ...): Tree is not binary. Birth-death branching trees should be binary, #>        but tree resonstruction from data may lead to  3+ descendants from #>        a single parent node. Proceed with caution! Input tree has #>       3 nodes directly descending from a single #>        parent node. A binary tree would only have 2 descendant nodes #>        from each parent node. Tree throwing warning is PD4781_1_clone1 ggtree(cloneTrees.list$PD5847_1_clone1) + layout_dendrogram() + geom_point2(aes(subset=(node==76)), shape=21, fill='red') resultsMaxLike <- suppressWarnings(maxLikelihood(cloneTrees.list))  # Preview the output print(head(resultsMaxLike[, c(1:3)])) #>                lowerBound  estimate upperBound #> PD34493_clone1 0.09732233 0.1687267  0.2401312 #> PD34493_clone3 0.17680977 0.2316003  0.2863907 #> PD34493_clone4 0.09428111 0.1957285  0.2971758 #> PD41305_clone1 0.17392864 0.3301275  0.4863263 #> PD41305_clone2 0.15906481 0.2757690  0.3924733 #> PD41305_clone3 0.32741598 0.5434498  0.7594836  # Check correlation of the estimates from the two methods print(stats::cor.test(resultsLengths$estimate, resultsMaxLike$estimate)) #>  #>  Pearson's product-moment correlation #>  #> data:  resultsLengths$estimate and resultsMaxLike$estimate #> t = 33.822, df = 40, p-value < 2.2e-16 #> alternative hypothesis: true correlation is not equal to 0 #> 95 percent confidence interval: #>  0.9683185 0.9908684 #> sample estimates: #>       cor  #> 0.9829619 # Check that column names are the same stopifnot(all(colnames(resultsMaxLike) == colnames(resultsLengths)))  # Print column names colnames(resultsMaxLike) #>  [1] \"lowerBound\"         \"estimate\"           \"upperBound\"         #>  [4] \"cloneAgeEstimate\"   \"sumInternalLengths\" \"sumExternalLengths\" #>  [7] \"extIntRatio\"        \"n\"                  \"alpha\"              #> [10] \"runtime_s\"          \"method\"             \"cloneName_result\" # Show the metadata of an individual without MPN print(cloneTrees.list$PD34493_clone1$metadata) #>        ID age cloneName_meta      cloneDriver diagnosis.age malnorm sourcePaper #> 1 PD34493  83 PD34493_clone1 SF3B1:k666n_DelY            NA  Normal       fabre  # And the metadata of an individual with MPN print(cloneTrees.list$PD9478_1_clone1$metadata) #>         ID      age  cloneName_meta                                cloneDriver #> 1 PD9478_1 68.75291 PD9478_1_clone1 JAK2:p.F537_K539delinsL_AND_DNMT3A:p.Y908* #>   diagnosis.age   malnorm sourcePaper #> 1            53 Malignant    williams # Combine all metadata into a single data.frame metadataAll <- do.call(rbind, lapply(cloneTrees.list, function(x) {   return(x$metadata) }))  # Preview and make sure everything looks right print(head(metadataAll)) #>                     ID age cloneName_meta      cloneDriver diagnosis.age #> PD34493_clone1 PD34493  83 PD34493_clone1 SF3B1:k666n_DelY            NA #> PD34493_clone3 PD34493  83 PD34493_clone3          unknown            NA #> PD34493_clone4 PD34493  83 PD34493_clone4          unknown            NA #> PD41305_clone1 PD41305  73 PD41305_clone1          unknown            NA #> PD41305_clone2 PD41305  73 PD41305_clone2          unknown            NA #> PD41305_clone3 PD41305  73 PD41305_clone3          unknown            NA #>                malnorm sourcePaper #> PD34493_clone1  Normal       fabre #> PD34493_clone3  Normal       fabre #> PD34493_clone4  Normal       fabre #> PD41305_clone1  Normal       fabre #> PD41305_clone2  Normal       fabre #> PD41305_clone3  Normal       fabre # Combine metadata with estimates using cbind. Check if cloneNames match resultsLengthsMeta <- cbind(resultsLengths, metadataAll) stopifnot(resultsLengthsMeta$cloneName_result == resultsLengthsMeta$cloneName_meta)  resultsMaxLikeMeta <- cbind(resultsMaxLike, metadataAll) stopifnot(resultsLengthsMeta$cloneName_result == resultsLengthsMeta$cloneName_meta)  # Because max. likelihood performs slightly better, use that going forward results <- resultsMaxLikeMeta"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-dataAnalysis.html","id":"analysis","dir":"Articles","previous_headings":"","what":"Analysis","title":"cloneRate Analysis of human blood data","text":", recreate analysis Figure 5E-G work. just many analyses can done data, don’t limited . split cohort MPN normal, might expect differences growth rates. number sampled cells, average, higher healthy individuals due study design, ’re likely pick clones healthy individuals. avoid bias much possible, ’ll compare mean growth rate individuals without MPN. First, want avoid double counting clones appear twice. three clones Williams paper: now, uniqueResults dataframe contains results one clone duplicated pair. Later , want validate estimates, ’ll make use fact different data clones, showing methods make consistent estimates regardless sampling time use. “Validation”.","code":"# If patient ID and clone number are the same, even if timepoint differs, then we have a duplicate # Make a new column for patient, removing anything after \"_\" from cloneName_result results$patient <- gsub(\"_.*\", \"\", results$cloneName_result) results$cloneNumber <- gsub(\".*_clone\", \"\", results$cloneName_result)  # Combining patient ID (without timepoint) and clone number will give us a unique ID for the clone regardless of sampling time results$uniqueCloneID <- paste0(results$patient, \"_\", results$cloneNumber)  # Find which clone IDs appear twice tmp <- table(results$uniqueCloneID) repeatsVec <- names(tmp)[tmp == 2]  # Remove the duplicate with fewer number of cells sequenced, n rowsRemove <- c() for (cloneID in repeatsVec) {   duplicateRows <- which(results$uniqueCloneID == cloneID)   removeIndex <- duplicateRows[which.min(results$n[duplicateRows])]   rowsRemove <- c(rowsRemove, removeIndex) }  uniqueResults <- results[!c(1:nrow(results)) %in% rowsRemove, ] # Check that each unique clone now only appears once (no duplicates) stopifnot(all(table(uniqueResults$uniqueCloneID) == 1))"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-dataAnalysis.html","id":"mpn-vs--normal-fig--5e","dir":"Articles","previous_headings":"Analysis","what":"MPN vs. Normal (Fig. 5E)","title":"cloneRate Analysis of human blood data","text":"Now, let’s take mean individual re-create Fig. 5E","code":"uniqueIndividuals <- unique(uniqueResults$patient) individualMeans <- c() malNorm <- c()  for (ind in uniqueIndividuals) {   individualMeans <- c(individualMeans, mean(uniqueResults$estimate[uniqueResults$patient == ind]))   malNorm <- c(malNorm, uniqueResults$malnorm[uniqueResults$patient == ind][1]) }  # Combine results into a data.frame mal_vs_norm.df <- data.frame(   \"Patient\" = uniqueIndividuals,   \"meanEstimate\" = individualMeans,   \"malNorm\" = malNorm )  # Run a non-parametric Mann-whitney test to see if they're significantly different nonparamTest <- wilcox.test(meanEstimate ~ malNorm, data = mal_vs_norm.df) print(nonparamTest) #>  #>  Wilcoxon rank sum exact test #>  #> data:  meanEstimate by malNorm #> W = 64, p-value = 0.02853 #> alternative hypothesis: true location shift is not equal to 0  # Set ordering for plot and plot using ggplot (re-make Fig. 5E) mal_vs_norm.df$malNorm <- factor(mal_vs_norm.df$malNorm, levels = c(\"Normal\", \"Malignant\")) ggplot(mal_vs_norm.df, aes(x = malNorm, y = meanEstimate)) +   geom_label(label = paste0(\"p = \", round(nonparamTest$p.value, 3)), x = 1.2, y = 1.2) +   geom_boxplot(width = 0.3, aes(color = malNorm), outlier.shape = NA) +   geom_jitter(aes(x = malNorm, y = meanEstimate, color = malNorm), width = .1, size = 2) +   scale_color_manual(values = c(\"black\", \"red\"), labels = c(\"Normal\", \"MPN\")) +   theme_bw() +   ylab(\"Mean net growth rate (r)\") +   xlab(\"\") +   theme(     legend.position = \"none\",     axis.ticks.x = element_blank(), axis.title.x = element_blank()   )"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-dataAnalysis.html","id":"single-vs--multi-driver-fig--5f","dir":"Articles","previous_headings":"Analysis","what":"Single vs. multi-driver (Fig. 5F)","title":"cloneRate Analysis of human blood data","text":"Taking results unique clones, uniqueResults, let’s compare growth rates clones either unknown driver single driver multiple drivers. , ’ll notice handy convention: drivers separated “”, clone “” driver column, multiple drivers:","code":"# Set the multi driver variable according to whether multiple drivers are annotated uniqueResults$multiDriver <- \"Single or unknown\" uniqueResults$multiDriver[grepl(\"AND\", uniqueResults$cloneDriver)] <- \"Multiple\"  # Run a non-parametric test to see if the differences are significant nonParamTest <- wilcox.test(estimate ~ multiDriver, data = uniqueResults) print(nonParamTest) #>  #>  Wilcoxon rank sum exact test #>  #> data:  estimate by multiDriver #> W = 276, p-value = 1.554e-06 #> alternative hypothesis: true location shift is not equal to 0  # Set levels to control plot order uniqueResults$multiDriver <- factor(uniqueResults$multiDriver, levels = c(\"Single or unknown\", \"Multiple\"))  # Plot colors <- c(\"#000000\", \"#E69F00\", \"#56B4E9\", \"#009E73\", \"#F0E442\", \"#0072B2\", \"#D55E00\", \"#CC79A7\") ggplot(uniqueResults, aes(x = multiDriver, y = estimate)) +   geom_boxplot(width = 0.3, aes(color = multiDriver), outlier.shape = NA) +   geom_jitter(aes(x = multiDriver, y = estimate, color = multiDriver), width = .1) +   scale_color_manual(values = c(colors[4], colors[8])) +   theme_bw() +   geom_label(label = paste0(\"p=\", round(nonParamTest$p.value, 7)), x = 1.5, y = 2) +   ylab(\"Net growth rate (r)\") +   xlab(\"\") +   ggtitle(\"Driver mutations\") +   theme(     legend.position = \"none\", axis.ticks.x = element_blank(),     axis.title.x = element_blank(), plot.title = element_text(hjust = .5)   )"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-dataAnalysis.html","id":"time-from-clone-initiation-to-diagnosis-fig--5g","dir":"Articles","previous_headings":"Analysis","what":"Time from clone initiation to diagnosis (Fig. 5G)","title":"cloneRate Analysis of human blood data","text":"discussed results data.frame (output internalLengths() maxLikelihood()) came clone age estimate, \\(1/r\\) + time sampling back first coalescence. birth rate clone \\(\\) death rate \\(b\\), net growth rate \\(r=-b\\). first coalescence represents first surviving division , neither offspring division die , ’ll account , average, half cells clone. means even sample 10 cells, ’re likely sample least one descendant two offspring, meaning first surviving division earliest coalescence, relative time sampling. know first surviving division occurs? Well, know: birth rate \\(\\) probability survival given individual \\((-b)/\\) \\(r/\\) leads rate surviving divisions equal \\(*r/= r\\). Therefore, expected waiting time clone initiation first surviving division \\(1/r\\). way, let’s see growth rate tells us anything time clone initiation diagnosis. , want use max. growth rate patient, ’s one ’d assume likely drive MPN initiation. don’t understand MPN well though, alternative use recently emerged clone prior diagnosis. ’ll , showing actually give results, probably clone arises later life must fit enough -compete clones already expanded. see 15/19 cases, youngest clone (>= 10 tips) also fit. First, let’s use fit clones stratify mean, reproducing result Figure 5G.  don’t fully understand clonal hematopoiesis MPN, ’s reasonable wonder whether using fittest clone best way compare time diagnosis. alternative, let’s compare youngest clones, seeing growth rate estimates still stratify time diagnosis. turns , youngest clone fittest clone 13 individuals diagnosed MPN. saw case 15 19 individuals including MPN healthy.","code":"# Get the clone IDs of the fittest clone in each patient cloneIDs_max <- sapply(unique(uniqueResults$patient), function(x) {   patient.df <- uniqueResults[uniqueResults$patient == x, ]   cloneID <- patient.df$cloneName_result[which.max(patient.df$estimate)]   cloneID })  # Get the clone IDs of the youngest clone in each patient cloneIDs_youngest <- sapply(unique(uniqueResults$patient), function(x) {   patient.df <- uniqueResults[uniqueResults$patient == x, ]   cloneID <- patient.df$cloneName_result[which.min(patient.df$cloneAgeEstimate)]   cloneID })  # See how much overlap there is between the most recent clone and the highest growth rate table(cloneIDs_max == cloneIDs_youngest) #>  #> FALSE  TRUE  #>     4    15 library(survival) library(ggsurvfit)  # Subset the results to only have the fittest clone for each patient maxResults <- uniqueResults[uniqueResults$cloneName_result %in% cloneIDs_max, ]  # Subset to the MPN patients malMax <- maxResults[maxResults$malnorm == \"Malignant\", ]  # Determine time from clone initiation to diagnosis malMax$latency_to_dx <- malMax$cloneAgeEstimate - (malMax$age - malMax$diagnosis.age)  # Stratify the population by the mean growth rate, adding a column \"aboveMean\" malMax$aboveMean <- malMax$estimate > mean(malMax$estimate)  # Use the survival package to see if differences are significant malMax$status <- 1 survivalTest <- survival::survdiff(survival::Surv(time = latency_to_dx, event = status) ~ aboveMean, data = malMax) print(survivalTest$pvalue) #> [1] 0.002628379  # Plot survival curves survfit2(Surv(time = latency_to_dx, event = status) ~ aboveMean, data = malMax) %>%   ggsurvfit() +   labs(     y = \"Probability diagnosis-free\",     x = \"Time from clone initiation (yrs.)\"   ) + scale_color_manual(values = c(colors[7], colors[3])) +   theme(legend.position = \"none\") +   geom_label(label = paste0(\"p = \", round(survivalTest$pvalue, 4)), x = 45, y = .85, color = \"black\", fill = \"white\") +   geom_label(label = \"r < mean\", x = 40, y = .375, color = colors[7], fill = \"white\") +   geom_label(label = \"r > mean\", x = 12, y = .35, color = colors[3], fill = \"white\") youngestResults <- uniqueResults[uniqueResults$cloneName_result %in% cloneIDs_youngest, ]  # Subset to the MPN patients malYoungest <- youngestResults[youngestResults$malnorm == \"Malignant\", ]  # Check how much overlap there is between youngest clone and fittest clone in the MPN dataset table(malYoungest$cloneName_result == malMax$cloneName_result) #>  #> TRUE  #>   13"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-dataAnalysis.html","id":"validation","dir":"Articles","previous_headings":"","what":"Validation","title":"cloneRate Analysis of human blood data","text":"Remember said three cases duplicate clones? Well, estimates worth anything, must consistent. means , three clones, expect estimates similar timepoints. Let’s check :  bad! ’s good consistent, ’s better consistent accurate. , need completely orthogonal way measure clonal growth rates, comes longitudinal data. One clones Williams paper two clones Fabre paper matching longitudinal data. formatted nicely comes package! Let’s now fit logistic curve longitudinal data estimate growth rate one clones, individual PD9478, tree showed beginning vignette. , recreating analysis Figure 6.  Now, let’s see estimate compares maximum likelihood estimate:  , bad! now, ’ll leave others explore. vignette already bit long. now tools reproduce analyses relating real data aspect paper. Hopefully able minutes hours, much better months took !","code":"# From before, we can find which clone IDs appear twice tmp <- table(results$uniqueCloneID) repeatsVec <- names(tmp)[tmp == 2]  # Subset the results to include only repeated clones repeatResults <- results[results$uniqueCloneID %in% repeatsVec, ]  # Plot the repeated clones ggplot(repeatResults) +   geom_pointrange(data = repeatResults, aes(     x = cloneName_result, y = estimate, ymin = lowerBound,     ymax = upperBound, color = uniqueCloneID   )) +   scale_color_manual(values = colors[c(1, 6, 7)]) +   theme_bw() +   ylab(\"Net growth rate estimate (r)\") +   theme(axis.text.x = element_blank(), axis.title.x = element_blank(), legend.title = element_blank()) library(car, quietly = T)  # Fit PD9478 PD9478_long <- longitudinalData[longitudinalData$Sample.ID == \"PD9478\", ]  # Get a rough estimate for starting params startingParams <- suppressWarnings(coef(lm(logit(VAF / .5) ~ Age, data = PD9478_long)))  # Fit to a three parameter logistic curve fit <- nls(VAF ~ K / (1 + exp(-(phi2 + r * Age))),   start = list(K = 0.2, phi2 = min(c(-0.000001, startingParams[1])), r = max(c(0.00001, startingParams[2]))),   data = PD9478_long, trace = F, algorithm = \"port\", lower = c(0, -500, 0.00001), upper = c(0.5, 0, 5) )  # Set output equal to summary of longitudinal models output <- summary(fit)  # Assign fitted params r <- output$coefficients[\"r\", 1] t_m <- -output$coefficients[\"phi2\", 1] / r # Get midpoint time by dividing by -1/r K <- output$coefficients[\"K\", 1]  # Get CI for growth rate of longitudinal/logistic model stdError <- output$coefficients[\"r\", \"Std. Error\"] lb <- r - 1.96 * stdError ub <- r + 1.96 * stdError  # Prepare a df for plotting the fit line along with the data x <- c((min(PD9478_long$Age) - 10):(max(PD9478_long$Age) + 10)) # construct a range of x values bounded by the data y <- K / (1 + exp(-(x - t_m) * r)) # curve VAF (3 param model)  predict.df <- data.frame(\"x\" = x, \"y\" = y)  fitColor <- colors[6]  ggplot(PD9478_long, aes(x = Age, y = VAF)) +   theme_bw() +   coord_cartesian(xlim = c(min(x), max(x)), ylim = c(-0.01, 0.52), expand = 0) +   labs(x = \"Person Age (yr)\", y = \"Variant Allele Frequency (VAF)\") +   ggtitle(gsub(\"_\", \" & \", paste0(PD9478_long$Sample.ID[1], \" \", PD9478_long$Gene[1]))) +   geom_line(data = predict.df, aes(x = x, y = y), color = fitColor, size = 1, show.legend = T) +   geom_point(color = \"#808080\", shape = 18) +   geom_vline(xintercept = t_m, linetype = \"dotted\", color = fitColor, linewidth = .6) +   geom_hline(yintercept = K, linetype = \"dotted\", color = fitColor, linewidth = .6) #> Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0. #> ℹ Please use `linewidth` instead. # Get the single cell estimate from PD9478 clone 1 scPD9478 <- results[results$cloneName_result == \"PD9478_1_clone1\", ]  combine.df <- data.frame(   \"Clone\" = \"PD9478_1_clone1\",   \"r\" = c(r, scPD9478$estimate),   \"lowerBound\" = c(lb, scPD9478$lowerBound),   \"upperBound\" = c(ub, scPD9478$upperBound),   \"method\" = c(\"longitudinal\", \"max. likelihood\") )  ggplot(combine.df) +   geom_pointrange(aes(x = method, y = r, ymin = lowerBound, ymax = upperBound)) +   theme_bw() +   ylab(\"Net growth rate (r)\")"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-dataAnalysis.html","id":"references-data-sources","dir":"Articles","previous_headings":"","what":"References / Data sources:","title":"cloneRate Analysis of human blood data","text":"real world data include produced annotated fascinating papers, advanced capabilities single-cell DNA sequencing. also provide excellent analysis addition provide work. Williams et al. 2022 Mitchell et al. 2022 Fabre et al. 2022 Van Egeren et al. 2021 mathematical methods estimating growth rates build large part work Amaury Lambert : Lambert, 2018 ’s final link paper details methods data analysis. enjoyed color palette plotting, tried use colorblind friendly colors, specifically pulling colors palette designed Bang Wong available .","code":""},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-simulate.html","id":"packages","dir":"Articles","previous_headings":"","what":"Packages","title":"cloneRate-simulate","text":"First, ’ll load packages want use. help understand ’re simulating, ’ll want able visualize trees. ggtree package help us . ggtree built using ggplot2 ’ll use well.","code":"# Load and attach our package cloneRate library(cloneRate)  # Install ggplot2 if necessary, then load and attach it with library() if (!requireNamespace(\"ggplot2\")) {   install.packages(\"ggplot2\") } library(ggplot2)  # Install ggtree if necessary, then load and attach it with library() if (!requireNamespace(\"ggtree\")) {   install.packages(\"ggtree\") } library(ggtree)"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-simulate.html","id":"simulating-ultrametric-trees","dir":"Articles","previous_headings":"","what":"Simulating ultrametric trees","title":"cloneRate-simulate","text":"’ll generating trees class phylo, fairly straightforward encoding phylogenetic trees R. ape documentation describing class phylo can found . First, let’s simulate single tree look class phylo. ’ll use function [simUltra()] package , simulates ultrametric tree. Ultrametric means tips equidistant root. ’ll set birth rate , death rate b, age tree cloneAge, number tips n. , best place get info class phylo . functions simulating trees include metadata. Let’s take look metadata included tree. see columns : r, , b: growth rate params. r net growth rate, birth rate b death rate, r=-b cloneAge: time passes, units r, , b. n: number tips sampled birth-death process, producing tree n tips. runtime_seconds: elapsed time generate tree. addStem: Tells us whether tree root edge preceding first split. ’ll show “stem” plots . Now let’s plot tree.  tree plotted , see “stem” edge extending time 0 first split. call splits coalescence times ’ll important methods growth rate estimation. Also, see tips ultrametric, meaning sampled time, case 20 units time birth-death process began. default, ’ll talk units time years, arbitrary. Just make sure units growth rate (per year) time units (years). Let’s apply growth rate estimates tree, seeing estimates close value r used generate tree. two functions estimating growth rate ultrametric tree, ’ll compare performance later : [internalLengths()]: function sums edge lengths internal edges tree (excluding stem). call sum \\(L_i\\). growth rate calculated \\(r = L_i / n\\) \\(n\\) number sampled tips.  methods detailed preprint. know actual growth rate 1, comparison judge estimates . One estimate doesn’t really tell us much though. Let’s try 100. , just set nTrees param equal 100 simUltra() function. can parallelize process parallel package installed simply setting nCores, ’ll leave 1 now. Let’s apply methods trees gave method 100 trees estimate, let’s plot estimates see perform. Remember input trees growth rate 1, want estimates close 1. ’ll use ggplot’s density plot :  bad, ’ll want test formally large range parameter values. later vignette. now, let’s shift attention mutation trees.","code":"# Generate the tree tree <- simUltra(a = 1, b = 0, cloneAge = 20, n = 100)  # We see that the tree is of class phylo class(tree) #> [1] \"phylo\"  # Preview the tree print(tree) #>  #> Phylogenetic tree with 100 tips and 100 internal nodes. #>  #> Tip labels: #>   t8, t24, t29, t50, t68, t95, ... #>  #> Rooted; includes branch lengths. print(tree$metadata) #>   r a b cloneAge   n runtime_seconds addStem #> 1 1 1 0       20 100           0.566    TRUE ggtree(tree) + theme_tree2(fgcolor = \"blue\") + xlab(\"Time\") maxLikelihood(tree) #>   lowerBound  estimate upperBound cloneAgeEstimate sumInternalLengths #> 1  0.7819396 0.9352259   1.088512               20           111.4954 #>   sumExternalLengths extIntRatio   n alpha runtime_s  method #> 1           1365.624    12.24825 100  0.05      0.06 maxLike  internalLengths(tree) #>   lowerBound  estimate upperBound cloneAgeEstimate sumInternalLengths #> 1  0.7211091 0.8968978   1.072687               20           111.4954 #>   sumExternalLengths extIntRatio   n alpha runtime_s  method #> 1           1365.624    12.24825 100  0.05     0.005 lengths tree.list <- simUltra(a = 1, b = 0, cloneAge = 20, n = 100, nTrees = 100, nCores = 1) resultsMaxLike <- maxLikelihood(tree.list)  resultsLengths <- internalLengths(tree.list) combineResults <- rbind(resultsLengths, resultsMaxLike)  ggplot(combineResults) + geom_density(aes(x = estimate, color = method)) +    theme_bw() + geom_vline(xintercept = 1)"},{"path":[]},{"path":"https://bdj34.github.io/cloneRate/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Brian Johnson. Maintainer, author. Yubo Shuai. Author. Jason Schweinsberg. Author. Kit Curtius. Author.","code":""},{"path":"https://bdj34.github.io/cloneRate/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Johnson, B., Shuai, Y., Schweinsberg, J., Curtius, K. Estimating single cell clonal dynamics human blood     using coalescent theory. 2023.","code":"@Article{,   title = {Estimating single cell clonal dynamics in human blood using coalescent theory},   author = {Brian Johnson and Yubo Shuai and Jason Schweinsberg and Kit Curtius},   journal = {NA},   year = {2023},   url = {NA}, }"},{"path":"https://bdj34.github.io/cloneRate/index.html","id":"clonerate-","dir":"","previous_headings":"","what":"Estimate growth rates from phylogenetic trees","title":"Estimate growth rates from phylogenetic trees","text":"goal cloneRate provide easily accessible methods estimating growth rate clones. input either ultrametric phylogenetic tree edge lengths corresponding time, non-ultrametric phylogenetic tree edge lengths corresponding mutation counts. case mutation-based edge lengths, mutation rate estimate also provided. package provides internal lengths maximum likelihood methods ultrametric trees shared mutations method mutation-based trees, recent preprint Estimating single cell clonal dynamics human blood using coalescent theory","code":""},{"path":"https://bdj34.github.io/cloneRate/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Estimate growth rates from phylogenetic trees","text":"can install development version cloneRate GitHub : basic tutorial vignettes, also use several packages, can installed CRAN. listed packages suggest, running following command install along vignettes. Alternatively, can install manually:","code":"# Install devtools if you don't have it already install.packages(setdiff(\"devtools\", rownames(installed.packages())))  # Install  devtools::install_github(\"bdj34/cloneRate\") devtools::install_github(\"bdj34/cloneRate\", build_vignettes = TRUE, dependencies = TRUE) install.packages(setdiff(c(\"ggplot2\", \"ggtree\", \"ggsurvfit\", \"survival\", \"car\"), rownames(installed.packages())))"},{"path":"https://bdj34.github.io/cloneRate/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Estimate growth rates from phylogenetic trees","text":"’ll walk simulating single tree plotting , apply growth rate methods.","code":""},{"path":"https://bdj34.github.io/cloneRate/index.html","id":"simulate-data","dir":"","previous_headings":"Example","what":"Simulate data","title":"Estimate growth rates from phylogenetic trees","text":"can simulate sample size n birth-death tree follows: Now simulated tree, let’s plot :  theme_tree2() function ggtree allows time scale added tree.","code":"library(cloneRate, quietly = T) library(ggtree, quietly = T) library(ggplot2, quietly = T)  # Generate a sampled tree with 100 tips from a 20 year birth-death process with birth rate a=1 and death rate b=0.5 tree <- simUltra(a = 1, b = 0.5, cloneAge = 40, n = 100) # Plot the tree (see ggtree docs for more advanced plotting) ggtree(tree) + theme_tree2(fgcolor = \"blue\") + xlab(\"Time (years)\")"},{"path":"https://bdj34.github.io/cloneRate/index.html","id":"estimate-growth-rate-of-one-tree","dir":"","previous_headings":"Example","what":"Estimate growth rate of one tree","title":"Estimate growth rates from phylogenetic trees","text":"can use tree input methods growth rate estimation:","code":"# Estimate the growth rate r=a-b=0.5 using maximum likelihood maxLike.df <- maxLikelihood(tree) print(paste0(\"Max. likelihood estimate = \", round(maxLike.df$estimate, 3))) #> [1] \"Max. likelihood estimate = 0.468\"  # Estimate the growth rate r=a-b=0.5 using internal lengths intLengths.df <- internalLengths(tree) print(paste0(\"Internal lengths estimate = \", round(intLengths.df$estimate, 3))) #> [1] \"Internal lengths estimate = 0.481\""},{"path":"https://bdj34.github.io/cloneRate/index.html","id":"estimate-growth-rate-of-many-trees","dir":"","previous_headings":"Example","what":"Estimate growth rate of many trees","title":"Estimate growth rates from phylogenetic trees","text":"paper, use simulated trees test growth rate estimates. example, let’s load simulated data comes package, exampleUltraTrees 100 ultrametric trees. “metadata” data.frame find ground truth growth rate, case 1. Let’s apply methods 100 trees. Notice functions maxLikelihood() internalLengths() can take input either single tree list trees. Either way, output data.frame containing results. Now 100 estimates 100 different trees 2 different methods, let’s plot distributions  Finally, let’s compute root mean square error (RMSE) estimates. expect maximum likelihhod perform best RMSE, 100 small sample size anything happen… expected, maximum likelihood performs best. Note may change regenerate data. details, see vignettes:","code":"# Here we are applying two methods to all of the ultrametric trees resultsUltraMaxLike <- maxLikelihood(exampleUltraTrees) resultsUltraLengths <- internalLengths(exampleUltraTrees) library(ggplot2, quietly = T)  # Combine all into one df for plotting. This works because the columns are the same resultsCombined <- rbind(resultsUltraMaxLike, resultsUltraLengths)  # Plot, adding a vertical line at r=1 because that's the true growth rate ggplot(resultsCombined) +   geom_density(aes(x = estimate, color = method)) +   geom_vline(xintercept = exampleUltraTrees[[1]]$metadata$r) +   theme_bw() # Calculate the RMSE groundTruth <- exampleUltraTrees[[1]]$metadata$r[1] rmse <- unlist(lapply(   split(resultsCombined, resultsCombined$method),   function(x) {     sqrt(sum((x$estimate - groundTruth)^2) / length(x$estimate))   } ))  print(rmse) #>    lengths    maxLike  #> 0.10049503 0.08869756 vignette(\"cloneRate-dataAnalysis\") vignette(\"cloneRate-simulate\")"},{"path":"https://bdj34.github.io/cloneRate/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Estimate growth rates from phylogenetic trees","text":"package comes 42 clones annotated four distinct publications, ones use analysis. Note three clones profiled two different timepoints, meaning 39 unique clones. vignettes code reproduce full analysis recent preprint coming soon! papers generate data : Williams et al. 2022 Mitchell et al. 2022 Fabre et al. 2022 Van Egeren et al. 2021 mathematical basis estimates detailed full paper. Simulating birth-death trees direct result work Amaury Lambert : Lambert, 2018","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/exampleMutTrees.html","id":null,"dir":"Reference","previous_headings":"","what":"Example mutation tree data — exampleMutTrees","title":"Example mutation tree data — exampleMutTrees","text":"Set 100 mutation based trees reconstructed distribution sample n=100 tips. trees net growth rate 1 birth rates 1 2 (sampled uniform distribution). Death rates equal chosen birth rate minus 1. Tree reconstruction uses exact distribution coalescence times described \"coalescent sample binary branching process\", Lambert ., Theor. Pop. Bio. 2018. Tree construction formatting uses ape R package ape::rcoal(). change edge lengths time-based mutation-based drawing poisson distribution mean equal edge length (units time) multiplied mutation rate, nu, drawn uniform distribution 10 20 mutations per year.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/exampleMutTrees.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example mutation tree data — exampleMutTrees","text":"","code":"data(exampleMutTrees)"},{"path":"https://bdj34.github.io/cloneRate/reference/exampleMutTrees.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example mutation tree data — exampleMutTrees","text":"list objects class phylo edge matrix edge connections reconstruct tree. edge.length numeric vector branch lengths connections edge matrix. Units mutations. tip.label character vector containing  (arbitrary case) labels 100 tips/samples tree. Nnode Integer number internal nodes tree params data.frame containing info params used generate tree","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/exampleMutTrees.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Example mutation tree data — exampleMutTrees","text":"data set created cloneRate package using coalescent theory approaches described \"coalescent sample binary branching process\", Lambert ., Theor. Pop. Bio. 2018.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/exampleMutTrees.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Example mutation tree data — exampleMutTrees","text":"","code":"library(ggtree) # Package for plotting phylogenetic trees by extending ggplot2 #> ggtree v3.6.2 For help: https://yulab-smu.top/treedata-book/ #>  #> If you use the ggtree package suite in published research, please cite #> the appropriate paper(s): #>  #> Guangchuang Yu, David Smith, Huachen Zhu, Yi Guan, Tommy Tsan-Yuk Lam. #> ggtree: an R package for visualization and annotation of phylogenetic #> trees with their covariates and other associated data. Methods in #> Ecology and Evolution. 2017, 8(1):28-36. doi:10.1111/2041-210X.12628 #>  #> Guangchuang Yu, Tommy Tsan-Yuk Lam, Huachen Zhu, Yi Guan. Two methods #> for mapping and visualizing associated data on phylogeny using ggtree. #> Molecular Biology and Evolution. 2018, 35(12):3041-3043. #> doi:10.1093/molbev/msy194 #>  #> Guangchuang Yu.  Data Integration, Manipulation and Visualization of #> Phylogenetic Trees (1st edition). Chapman and Hall/CRC. 2022, #> doi:10.1201/9781003279242  ggtree(cloneRate::exampleMutTrees[[1]]) # Plot first of 100 trees"},{"path":"https://bdj34.github.io/cloneRate/reference/exampleUltraTrees.html","id":null,"dir":"Reference","previous_headings":"","what":"Example ultrametric tree data — exampleUltraTrees","title":"Example ultrametric tree data — exampleUltraTrees","text":"Set 100 time-based ultrametric trees reconstructed distribution sample n=100 tips. trees net growth rate 1 birth rates 1 2 (sampled uniform distribution). Death rates equal chosen birth rate minus 1. Tree reconstruction uses exact distribution coalescence times described \"coalescent sample binary branching process\", Lambert ., Theor. Pop. Bio. 2018. Tree construction formatting uses ape R package ape::rcoal().","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/exampleUltraTrees.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example ultrametric tree data — exampleUltraTrees","text":"","code":"data(exampleUltraTrees)"},{"path":"https://bdj34.github.io/cloneRate/reference/exampleUltraTrees.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example ultrametric tree data — exampleUltraTrees","text":"list objects class phylo edge matrix edge connections reconstruct tree. edge.length numeric vector branch lengths connections edge matrix. Units years. tip.label character vector containing  (arbitrary case) labels 100 tips/samples tree. Nnode Integer number internal nodes tree params data.frame containing info params used generate tree","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/exampleUltraTrees.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Example ultrametric tree data — exampleUltraTrees","text":"data set created cloneRate package using coalescent theory approaches described \"coalescent sample binary branching process\", Lambert ., Theor. Pop. Bio. 2018.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/exampleUltraTrees.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Example ultrametric tree data — exampleUltraTrees","text":"","code":"library(ggtree) # Package for plotting phylogenetic trees by extending ggplot2 ggtree(cloneRate::exampleUltraTrees[[1]]) # Plot first of 100 trees"},{"path":"https://bdj34.github.io/cloneRate/reference/inputCheck.html","id":null,"dir":"Reference","previous_headings":"","what":"Check the inputs to growth rate functions — inputCheck","title":"Check the inputs to growth rate functions — inputCheck","text":"Check validity inputs growth rate fns, making sure tree ultrametric ape phylo object reasonable alpha","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/inputCheck.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check the inputs to growth rate functions — inputCheck","text":"","code":"inputCheck(tree, alpha)"},{"path":"https://bdj34.github.io/cloneRate/reference/inputCheck.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check the inputs to growth rate functions — inputCheck","text":"tree ape tree subset include clone interest alpha Used calculation confidence intervals. 1-alpha confidence intervals used default alpha = 0.05 (95 percent confidence intervals)","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/internalLengths.html","id":null,"dir":"Reference","previous_headings":"","what":"Growth rate estimate using the sum of internal lengths — internalLengths","title":"Growth rate estimate using the sum of internal lengths — internalLengths","text":"internalLengths() provides estimate net growth rate clone confidence bounds, using internal lengths method.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/internalLengths.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Growth rate estimate using the sum of internal lengths — internalLengths","text":"","code":"internalLengths(tree, alpha = 0.05)"},{"path":"https://bdj34.github.io/cloneRate/reference/internalLengths.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Growth rate estimate using the sum of internal lengths — internalLengths","text":"tree ultrametric tree subset include clone interest. Alternatively, list several trees. alpha Used calculation confidence intervals. 1-alpha confidence intervals used default alpha = 0.05 (95 percent confidence intervals)","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/internalLengths.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Growth rate estimate using the sum of internal lengths — internalLengths","text":"dataframe including net growth rate estimate, sum internal lengths important details (clone age estimate, runtime, n, etc.)","code":""},{"path":[]},{"path":"https://bdj34.github.io/cloneRate/reference/internalLengths.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Growth rate estimate using the sum of internal lengths — internalLengths","text":"","code":"internalLengths(cloneRate::exampleUltraTrees[[1]]) #>   lowerBound estimate upperBound cloneAgeEstimate sumInternalLengths #> 1  0.8337313 1.036975   1.240218               20           96.43438 #>   sumExternalLengths extIntRatio   n alpha runtime_s  method #> 1           1294.319    13.42176 100  0.05     0.006 lengths"},{"path":"https://bdj34.github.io/cloneRate/reference/longitudinalData.html","id":null,"dir":"Reference","previous_headings":"","what":"Longitudinal validation data — longitudinalData","title":"Longitudinal validation data — longitudinalData","text":"three individuals clonal expansions can estimated using methods, longitudinal data orthogonally validate estimates, provided .","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/longitudinalData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Longitudinal validation data — longitudinalData","text":"","code":"longitudinalData"},{"path":"https://bdj34.github.io/cloneRate/reference/longitudinalData.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Longitudinal validation data — longitudinalData","text":"data.frame containing information needed Sample.ID individual's ID Age Individual's age various sampling times VAF variant allele frequency various sampling times clone interest Gene Gene genes mutation identifies clone Protein Protein affected mutation cellType type cells used sequencing cloneName name use clone match single cell data","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/longitudinalData.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Longitudinal validation data — longitudinalData","text":"datasets generated annotated : Williams et al. 2022 Fabre et al. 2022","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/longitudinalData.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Longitudinal validation data — longitudinalData","text":"","code":"library(ggplot2) # Plot longitudinal data from PD9478 ggplot(longitudinalData[longitudinalData$Sample.ID == \"PD9478\", ]) +   geom_point(aes(x = Age, y = VAF))"},{"path":"https://bdj34.github.io/cloneRate/reference/maxLikelihood.html","id":null,"dir":"Reference","previous_headings":"","what":"Growth rate estimate using Maximum Likelihood — maxLikelihood","title":"Growth rate estimate using Maximum Likelihood — maxLikelihood","text":"Uses approximation coalescence times H_i equal +b*U_i find b. b equal 1/r, r net growth rate.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/maxLikelihood.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Growth rate estimate using Maximum Likelihood — maxLikelihood","text":"","code":"maxLikelihood(tree, alpha = 0.05)"},{"path":"https://bdj34.github.io/cloneRate/reference/maxLikelihood.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Growth rate estimate using Maximum Likelihood — maxLikelihood","text":"tree ultrametric tree subset include clone interest. Alternatively, list several trees. alpha Used calculation confidence intervals. 1-alpha confidence intervals used default alpha = 0.05 (95 percent confidence intervals)","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/maxLikelihood.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Growth rate estimate using Maximum Likelihood — maxLikelihood","text":"dataframe including net growth rate estimate, confidence intervals, important details (clone age estimate, runtime, n, etc.)","code":""},{"path":[]},{"path":"https://bdj34.github.io/cloneRate/reference/maxLikelihood.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Growth rate estimate using Maximum Likelihood — maxLikelihood","text":"","code":"df <- maxLikelihood(cloneRate::exampleUltraTrees[[1]])"},{"path":"https://bdj34.github.io/cloneRate/reference/realCloneData.html","id":null,"dir":"Reference","previous_headings":"","what":"Real clone data from human blood — realCloneData","title":"Real clone data from human blood — realCloneData","text":"42 clones (39 distinct) 32 individual donors, 13 diagnosis Myeloproliferative Neoplasm","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/realCloneData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Real clone data from human blood — realCloneData","text":"","code":"data(realCloneData)"},{"path":"https://bdj34.github.io/cloneRate/reference/realCloneData.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Real clone data from human blood — realCloneData","text":"list containing one list full ultrametric trees 30 32 individual donors (two Van Egeren included), one list containing 42 clone trees.three cases, two timepoints clone, separate phylo objects. list contains tree class phylo object. See ape package documentation details class phylo objects. Names phylo object (tree) list matches naming used sources also includes driver, age, clone number.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/realCloneData.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Real clone data from human blood — realCloneData","text":"https://pubmed.ncbi.nlm.nih.gov/35058638/ https://pubmed.ncbi.nlm.nih.gov/35650442/ https://pubmed.ncbi.nlm.nih.gov/35650444/ https://pubmed.ncbi.nlm.nih.gov/33621486/","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/realCloneData.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Real clone data from human blood — realCloneData","text":"datasets generated annotated : Williams et al. 2022 Mitchell et al. 2022 Fabre et al. 2022 Van Egeren et al. 2021","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/realCloneData.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Real clone data from human blood — realCloneData","text":"","code":"# Plot full reconstructed tree from donor PD34493 plot(cloneRate::realCloneData[[\"fullTrees\"]][[\"PD34493\"]])"},{"path":"https://bdj34.github.io/cloneRate/reference/sharedMuts.html","id":null,"dir":"Reference","previous_headings":"","what":"Growth rate estimate using the sum of shared mutations assuming a mutation tree — sharedMuts","title":"Growth rate estimate using the sum of shared mutations assuming a mutation tree — sharedMuts","text":"sharedMuts() provides estimate net growth rate clone confidence bounds, using shared mutations method.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/sharedMuts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Growth rate estimate using the sum of shared mutations assuming a mutation tree — sharedMuts","text":"","code":"sharedMuts(tree, nu = NULL, alpha = 0.05)"},{"path":"https://bdj34.github.io/cloneRate/reference/sharedMuts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Growth rate estimate using the sum of shared mutations assuming a mutation tree — sharedMuts","text":"tree non-ultrametric ape tree subset include clone interest nu mutation rate. none given, sharedMuts() first look nu column metadata data.frame tree, look nu tree . throw error nu given found. alpha Used calculation confidence intervals. 1-alpha confidence intervals used default alpha = 0.05 (95 percent confidence intervals)","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/sharedMuts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Growth rate estimate using the sum of shared mutations assuming a mutation tree — sharedMuts","text":"dataframe including net growth rate estimate, sum internal lengths important details (clone age estimate, runtime, n, etc.)","code":""},{"path":[]},{"path":"https://bdj34.github.io/cloneRate/reference/sharedMuts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Growth rate estimate using the sum of shared mutations assuming a mutation tree — sharedMuts","text":"","code":"sharedMuts(cloneRate::exampleMutTrees[[1]]) #>   lowerBound estimate upperBound       nu cloneAgeEstimate sharedMutations #> 1  0.9236845  1.16662   1.409555 18.67758         20.29171            1601 #>   privateMutations extIntRatio   n alpha runtime_s     method #> 1            16944    10.58339 100  0.05     0.006 sharedMuts"},{"path":"https://bdj34.github.io/cloneRate/reference/simMut.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate mutation-based birth and death branching trees — simMut","title":"Simulate mutation-based birth and death branching trees — simMut","text":"Generates sampled tree (list many sampled trees) supercritial (birth rate > death rate) birth death branching process according coalescent point process described \"Lambert, . coalescent sample binary branching process. (2018).\" Edge lengths units mutations, assuming poissonian mutation accumulation. Essentially wrapper combining simUltra() ultra2mut() functions one step.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/simMut.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate mutation-based birth and death branching trees — simMut","text":"","code":"simMut(   a,   b,   cloneAge,   n,   nu,   nTrees = 1,   precBits = 1000,   addStem = T,   nCores = 1 )"},{"path":"https://bdj34.github.io/cloneRate/reference/simMut.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate mutation-based birth and death branching trees — simMut","text":"Birth rate b Death rate cloneAge Clone age. Make sure time units birth death rates n Number samples/tips tree returned nu Mutation rate units mutations per unit time. Make sure time units consistent birth death rates cloneAge nTrees Integer indicating number trees generate. Default 1. precBits Rmpfr param handling high precision numbers. Needed draw coalescence times. addStem Boolean indicating whether add stem tree preceding first split/coalescence nCores Integer indicating number cores use parallel pkg installed. Default 1.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/simMut.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate mutation-based birth and death branching trees — simMut","text":"ape object class \"phylo\" representing ultrametric phylogenetic tree edge lengths units time. Tree metadata located 'metadata' data.frame included \"phylo\" object. 'nTrees' param greater 1, simUltra returns list objects objects class \"phylo\".","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/simMut.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate mutation-based birth and death branching trees — simMut","text":"","code":"# Generate a single mutation-based tree with a specified mutation rate tree <- simMut(a = 1, b = 0.5, cloneAge = 40, n = 50, nu = 10)  # Generate a list of mutation-based trees with a range of mutation rates tree_list <- simMut(   a = 1, b = 0.5, cloneAge = 40, n = 50,   nu = stats::runif(n = 10, min = 10, max = 20), nTrees = 10 )"},{"path":"https://bdj34.github.io/cloneRate/reference/simUltra.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate ultrametric birth and death branching trees — simUltra","title":"Simulate ultrametric birth and death branching trees — simUltra","text":"Generates sampled tree (list many sampled trees) supercritial (birth rate > death rate) birth death branching process according coalescent point process described \"Lambert, . coalescent sample binary branching process. (2018).\"","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/simUltra.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate ultrametric birth and death branching trees — simUltra","text":"","code":"simUltra(   a,   b,   cloneAge,   n,   nTrees = 1,   precBits = 1000,   addStem = T,   nCores = 1 )"},{"path":"https://bdj34.github.io/cloneRate/reference/simUltra.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate ultrametric birth and death branching trees — simUltra","text":"Birth rate vector birth rates length 'nTrees' b Death rate vector death rates length 'nTrees' cloneAge Clone age vector clone ages length 'nTrees'. Make sure time units birth death rates n Number samples/tips tree returned. Can vector length 'nTrees' well. nTrees Integer indicating number trees generate. Default 1 precBits Rmpfr param handling high precision numbers. Needed drawing coalescence times. Can vector length 'nTrees', though recommended addStem Boolean indicating whether add stem tree preceding first split/coalescence. Can also vector length 'nTrees' nCores Integer indicating number cores use parallel pkg installed. Default 1.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/simUltra.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate ultrametric birth and death branching trees — simUltra","text":"ape object class \"phylo\" representing ultrametric phylogenetic tree edge lengths units time. Tree metadata located 'metadata' data.frame included \"phylo\" object. 'nTrees' param greater 1, simUltra returns list objects objects class \"phylo\".","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/simUltra.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate ultrametric birth and death branching trees — simUltra","text":"","code":"# Generate a single tree tree <- simUltra(a = 1, b = 0.5, cloneAge = 20, n = 50)  # Generate a list of trees tree_list <- simUltra(a = 1, b = 0.5, cloneAge = 20, n = 50, nTrees = 10)"},{"path":"https://bdj34.github.io/cloneRate/reference/siteFrequency.html","id":null,"dir":"Reference","previous_headings":"","what":"Get site frequency spectrum of a tree — siteFrequency","title":"Get site frequency spectrum of a tree — siteFrequency","text":"siteFrequency() returns data.frame frequency units time mutations, well normalized frequency.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/siteFrequency.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get site frequency spectrum of a tree — siteFrequency","text":"","code":"siteFrequency(tree, includeStem = F)"},{"path":"https://bdj34.github.io/cloneRate/reference/siteFrequency.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get site frequency spectrum of a tree — siteFrequency","text":"tree ultrametric mutation-based tree subset include clone interest. Alternatively, list several trees. includeStem Boolean indicating whether count stem tree contributing site frequency distribution. Default FALSE.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/siteFrequency.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get site frequency spectrum of a tree — siteFrequency","text":"data.frame three columns: number descendant cells, site frequency units time mutations, normalized site frequency. list trees input, output list data.frames.","code":""},{"path":[]},{"path":"https://bdj34.github.io/cloneRate/reference/siteFrequency.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get site frequency spectrum of a tree — siteFrequency","text":"","code":"# Get site frequency of a single tree example.df <- siteFrequency(exampleUltraTrees[[1]])  # Get site frequency of a list of trees example.list <- siteFrequency(exampleMutTrees)"},{"path":"https://bdj34.github.io/cloneRate/reference/ultra2mut.html","id":null,"dir":"Reference","previous_headings":"","what":"Add poissonian mutations to an ultrametric tree(s) — ultra2mut","title":"Add poissonian mutations to an ultrametric tree(s) — ultra2mut","text":"Takes ultrametric tree class \"phylo\" (list trees) draws new edge lengths units mutations, mean new edge length equal old edge length multiplied mutation rate. Mutation rate can set drawn uniform distribution.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/ultra2mut.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add poissonian mutations to an ultrametric tree(s) — ultra2mut","text":"","code":"ultra2mut(tree, nu)"},{"path":"https://bdj34.github.io/cloneRate/reference/ultra2mut.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add poissonian mutations to an ultrametric tree(s) — ultra2mut","text":"tree single tree list trees class \"phylo\", edge lengths units time nu Mutation rate units mutations per unit time. Can also vector mutation rates length equal number input trees. Make sure time units consistent nu tree$edge.length","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/ultra2mut.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add poissonian mutations to an ultrametric tree(s) — ultra2mut","text":"ape object class \"phylo\" representing phylogenetic tree edge lengths units mutations. Value mutation rate added 'metadata' data.frame output tree data.frame exists input tree. Otherwise, mutation rate value added \"phylo\" object directly. input list trees, ultra2mut() return list \"phylo\" objects.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/ultra2mut.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add poissonian mutations to an ultrametric tree(s) — ultra2mut","text":"","code":"# Convert the time-based, ultrametric example trees into mutation-based trees mutTrees <- ultra2mut(exampleUltraTrees,   nu = stats::runif(n = length(exampleUltraTrees), min = 10, max = 20) )"},{"path":"https://bdj34.github.io/cloneRate/news/index.html","id":"clonerate-001","dir":"Changelog","previous_headings":"","what":"cloneRate 0.0.1","title":"cloneRate 0.0.1","text":"Added NEWS.md file track changes package.","code":""}]
