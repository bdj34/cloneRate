[{"path":"https://bdj34.github.io/cloneRate/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 cloneRate authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-dataAnalysis.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Analysis of human blood data","text":"First, ’ll load packages want use. ’ll plotting trees using ape package function ape::plot.phylo() along ape functions. cloneRate installed, already ape package. ’ll also using ggplot2 make plots, well survival, ggsurvfit, car downstream analysis. can installed CRAN. ’ll also set colors ’ll use plotting. palette available ","code":"# Load and attach our package cloneRate library(cloneRate)  # Load and attach ape library(ape)  # Install from CRAN if necessary, then load and attach with library() library(ggplot2) library(survival) library(ggsurvfit) library(car) colorPal <- c(\"#000000\", \"#E69F00\", \"#56B4E9\", \"#009E73\", \"#F0E442\", \"#0072B2\", \"#D55E00\", \"#CC79A7\")"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-dataAnalysis.html","id":"data-exploration","dir":"Articles","previous_headings":"","what":"Data exploration","title":"Analysis of human blood data","text":"First, let’s examine realCloneData, contains necessary data reproduce analysis. two lists contained dataset, one contains full reconstructed tree individual timepoint (named fullTrees), one contains specific clones full trees (named cloneTrees). require clone must least n=10 tips (sampled cells) included cloneTrees. discuss requirement simulation vignette. now, let’s split two different variables clarity.","code":"summary(cloneRate::realCloneData) #>            Length Class  Mode #> fullTrees  30     -none- list #> cloneTrees 42     -none- list fullTrees.list <- cloneRate::realCloneData$fullTrees cloneTrees.list <- cloneRate::realCloneData$cloneTrees"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-dataAnalysis.html","id":"full-trees","dir":"Articles","previous_headings":"Data exploration","what":"Full trees","title":"Analysis of human blood data","text":"Let’s start looking full tree single individual, “PD9478”. individuals study sequenced multiple timepoints, refer ID (“PD9478”) timepoint (“_1”) get specific tree fullTrees.list. case, timepoint timepoint 1, let’s take look full tree “PD9478_1”. data comes work Williams et al. see tree class phylo(http://ape-package.ird.fr/misc/FormatTreeR_24Oct2012.pdf), fairly straightforward encoding phylogenetic trees R. Let’s plot tree:","code":"# Let's see the class of the tree PD9478 <- fullTrees.list$PD9478_1 class(PD9478) #> [1] \"phylo\" # Plot the full tree from individual PD9478 at timepoint 1 PD9478 <- fullTrees.list$PD9478_1  # Plot, then add scale and title plot.phylo(PD9478,   direction = \"downwards\",   show.tip.label = FALSE, edge.width = 2,   edge.color = c(rep(\"black\", 2), \"red\", \"#0070C0\", rep(\"black\", (200))) ) axisPhylo(side = 2, backward = FALSE, las = 1) title(main = \"PD9478 full tree\", ylab = \"Time (years)\")"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-dataAnalysis.html","id":"clone-trees","dir":"Articles","previous_headings":"Data exploration","what":"Clone trees","title":"Analysis of human blood data","text":"went simulation vignette, ’ll notice tree looks quite bit different ones simulated. tree, clear example somatic clonal expansion. know authors produced data (see Williams et al. Fig. 3 PD9478), sampled cells within clone mutation JAK2 gene (occurs along red edge) DNMT3A gene (occurs along blue edge). mutations known important clonal expansions blood. Let’s look closely clone see can learn tree.  Now tree clonal expansion looks lot like trees simulate! suggests growth rate cell within clone roughly cells within clone. can now apply methods clone tree shown !","code":"# Load the clone tree from our cloneTrees.list PD9478_subClone <- cloneTrees.list[[\"PD9478_1_clone1\"]]  # Plot, then add scale and title plot.phylo(PD9478_subClone,   direction = \"downwards\",   show.tip.label = FALSE, edge.width = 2, ) axisPhylo(side = 2, backward = FALSE, las = 1) title(main = \"PD9478 JAK2 & DNMT3A clone tree\", ylab = \"Time (years)\")"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-dataAnalysis.html","id":"estimating-growth-rates","dir":"Articles","previous_headings":"","what":"Estimating growth rates","title":"Analysis of human blood data","text":"see tree ultrametric know ’s time-based, units years, apply internalLengths() maxLikelihood() functions. Unfortunately, don’t ground truth compare working real data. However, individual clone longitudinal sequencing data, can use estimate orthogonal growth rate. ’ll come back later (see Validation). First, let’s apply analysis clone trees. give list phylo objects, growth rate functions estimate growth rate separately, returning data.frame row telling us result tree. Oof! Looks like warning… says two trees input “PD5847_1_clone1” “PD4781_1_clone1” binary branching trees. means one node 2 direct descendants. case, ’s big deal. know trees resconstructed mutation data, just mean picked two divisions happened without mutations occurring . Let’s plot one can see happens  can see three descendants single node (node 76), identified edges orange. see lot places multiple splits (coalescence events) quick succession, place 1 node appears split 3. ’s okay; know mutations imperfect way keep track time. saw events one node splits 3, cases one node splits 4+, might concerned. case, can move . functions growth rate estimation equipped handle trees like , throw warnings know ’s happening. Let’s continue, applying maxLikelihood() function trees. bad! correlation coefficient around 0.98, estimates method agree well. want compare estimates birth-death MCMC well, ’ll include example run , won’t include results tends take longer run. note high correlation (\\(R^2 > 0.99\\)) birth-death MCMC maximum likelihood estimate:","code":"# Get maximum likelihood and internal lengths estimates print(round(maxLikelihood(PD9478_subClone)$estimate, 3)) #> [1] 0.516 print(round(internalLengths(PD9478_subClone)$estimate, 3)) #> [1] 0.601 # Apply each of our estimates resultsLengths <- internalLengths(cloneTrees.list) #> Warning in FUN(X[[i]], ...): Tree is not binary. Birth-death branching trees should be binary, #>        but tree resonstruction from data may lead to  3+ descendants from #>        a single parent node. Proceed with caution! Input tree has #>       3 nodes directly descending from a single #>        parent node. A binary tree would only have 2 descendant nodes #>        from each parent node. Tree throwing warning is PD5847_1_clone1 #> Warning in FUN(X[[i]], ...): Tree is not binary. Birth-death branching trees should be binary, #>        but tree resonstruction from data may lead to  3+ descendants from #>        a single parent node. Proceed with caution! Input tree has #>       3 nodes directly descending from a single #>        parent node. A binary tree would only have 2 descendant nodes #>        from each parent node. Tree throwing warning is PD4781_1_clone1 # Plot, highlighting the 3 descendants of node 76. Then add scale and title plot.phylo(cloneTrees.list$PD5847_1_clone1,   edge.width = 2,   direction = \"downwards\", show.tip.label = FALSE,   edge.color = c(     rep(1, 4), \"darkorange\", rep(1, 34),     \"darkorange\", rep(1, 6), \"darkorange\", rep(1, 1000)   ) ) axisPhylo(side = 2, backward = FALSE, las = 1) title(main = \"PD5847 clone 1 tree (multi-branching)\", ylab = \"Time (years)\") resultsMaxLike <- suppressWarnings(maxLikelihood(cloneTrees.list))  # Preview the output print(head(resultsMaxLike[, c(1:3)])) #>                lowerBound  estimate upperBound #> PD34493_clone1 0.09733005 0.1687401  0.2401502 #> PD34493_clone3 0.17679235 0.2315774  0.2863625 #> PD34493_clone4 0.09425558 0.1956755  0.2970954 #> PD41305_clone1 0.17395097 0.3301699  0.4863887 #> PD41305_clone2 0.15904836 0.2757405  0.3924327 #> PD41305_clone3 0.32745600 0.5435162  0.7595764  # Print correlation coefficient of the estimates from the two methods print(stats::cor.test(resultsLengths$estimate, resultsMaxLike$estimate)$estimate) #>       cor  #> 0.9829572 # Longer running code. Not run as part of vignette. resultsBDMCMC <- suppressWarnings(birthDeathMCMC(cloneTrees.list))  # Print correlation coefficient of the estimates from the two methods print(stats::cor.test(resultsBDMCMC$estimate, resultsMaxLike$estimate)$estimate) # >  cor # > 0.9964975"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-dataAnalysis.html","id":"understanding-the-function-outputs","dir":"Articles","previous_headings":"Estimating growth rates","what":"Understanding the function outputs","title":"Analysis of human blood data","text":"functions (maxLikelihood(), internalLengths() birthDeathMCMC()) returns data.frame columns, ’ll walk columns mean : lowerBound, estimate, upperBound: growth rate estimate confidence intervals. default 95% confidence intervals, can adjusted setting alpha parameter function input. cloneAgeEstimate estimate time clone initiation sampling. earliest coalescence time clone tree gives us rough estimate clone age, add \\(1/r\\),1 divided growth rate estimate, account expected time initiation first surviving division (first coalescence). ’ll discuss later. sumInternalLengths, sumExternalLengths, extintRatio: sum internal edge lengths, external edge lengths, ratio two. use ratio say whether enough time passed use method (see simulation vignette). Fortunately, real data ratio > 3, can apply methods clone trees. n number tips clone tree. case, corresponds number cells sequenced clone. alpha confidence level. default 0.05, use 1-alpha (default 95%) confidence intervals upper lower bounds. runtime_s runtime method seconds. method method used, helps want combine data.frames different methods plotting. cloneName_result unique name clone corresponding individual ID clone number. individuals Williams paper, individuals sampled multiple timepoints, ID followed “_1”, “_2”, “_3” indicate timepoint.","code":"# Check that column names are the same stopifnot(all(colnames(resultsMaxLike) == colnames(resultsLengths)))  # Print column names colnames(resultsMaxLike) #>  [1] \"lowerBound\"         \"estimate\"           \"upperBound\"         #>  [4] \"cloneAgeEstimate\"   \"sumInternalLengths\" \"sumExternalLengths\" #>  [7] \"extIntRatio\"        \"n\"                  \"alpha\"              #> [10] \"runtime_s\"          \"method\"             \"cloneName_result\""},{"path":[]},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-dataAnalysis.html","id":"metadata","dir":"Articles","previous_headings":"Downstream analysis","what":"Metadata","title":"Analysis of human blood data","text":"Now growth rates, let’s make sense . look inside cloneTrees.list, realize also metadata. Let’s print two examples, one individual Myeloproliferative Neoplasm (MPN), one without: biological /clinical analysis, important : age tells us individual’s age time sampling. know clonal hematopoiesis associated aging. cloneDriver tells us clonal hematopoiesis driver(s) likely leads expansion. diagnosis.age tells us individual diagnosed Myeloproliferative Neoplasm (MPN). individual doesn’t MPN, diagnosis.age NA. malnorm tells us whether individual diagnosed Myeloproliferative Neoplasm (MPN). information already conveyed diagnosis.age, ’s sometimes easier work format. Let’s combine cloneTrees.list metadata one data.frame, can analyze together results running functions. Let’s join data.frames containing metadata results. can use cbind() know order metadata order results data.frame. can check comparing cloneName_result cloneName_meta columns, () . ’ll go forward analysis using results data.frame, contains estimates maxLikelihood() function metadata. simulation vignette, show maximum likelihood estimate performs better internalLengths() estimate.","code":"# Show the metadata of an individual without MPN print(cloneTrees.list$PD34493_clone1$metadata) #>        ID age cloneName_meta      cloneDriver diagnosis.age malnorm sourcePaper #> 1 PD34493  83 PD34493_clone1 SF3B1:k666n_DelY            NA  Normal       fabre  # And the metadata of an individual with MPN print(cloneTrees.list$PD9478_1_clone1$metadata) #>         ID      age  cloneName_meta                                cloneDriver #> 1 PD9478_1 68.75291 PD9478_1_clone1 JAK2:p.F537_K539delinsL_AND_DNMT3A:p.Y908* #>   diagnosis.age   malnorm sourcePaper #> 1            53 Malignant    williams # Combine all metadata into a single data.frame metadataAll <- do.call(rbind, lapply(cloneTrees.list, function(x) {   return(x$metadata) })) # Combine metadata with estimates using cbind. Check if cloneNames match resultsLengthsMeta <- cbind(resultsLengths, metadataAll) stopifnot(resultsLengthsMeta$cloneName_result == resultsLengthsMeta$cloneName_meta)  resultsMaxLikeMeta <- cbind(resultsMaxLike, metadataAll) stopifnot(resultsLengthsMeta$cloneName_result == resultsLengthsMeta$cloneName_meta)  # Because max. likelihood performs slightly better, use that going forward results <- resultsMaxLikeMeta"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-dataAnalysis.html","id":"recreating-figures","dir":"Articles","previous_headings":"Downstream analysis","what":"Recreating figures","title":"Analysis of human blood data","text":", recreate analysis Figure 5E-G work. just many analyses can done data, don’t limited . split cohort MPN normal, might expect differences growth rates. number sampled cells, average, higher healthy individuals due study design differences, ’re likely pick clones healthy individuals. avoid bias much possible, ’ll compare mean growth rate individuals without MPN. First, want avoid double counting clones appear twice. three clones Williams paper: now, uniqueResults dataframe contains results one clone duplicated pair. Later , want validate estimates, ’ll make use fact data different timepoints clone, showing methods make consistent estimates regardless sampling time use. Validation section.","code":"# If patient ID and clone number are the same, even if timepoint # differs, then we have a duplicate. # Make a new column for patient, removing anything after \"_\" from cloneName_result results$patient <- gsub(\"_.*\", \"\", results$cloneName_result) results$cloneNumber <- gsub(\".*_clone\", \"\", results$cloneName_result)  # Combining patient ID (without timepoint) and clone number # will give us a unique ID for the clone regardless of sampling time results$uniqueCloneID <- paste0(results$patient, \"_\", results$cloneNumber)  # Find which clone IDs appear twice tmp <- table(results$uniqueCloneID) repeatsVec <- names(tmp)[tmp == 2]  # Remove the duplicate with fewer number of cells sequenced, n rowsRemove <- c() for (cloneID in repeatsVec) {   duplicateRows <- which(results$uniqueCloneID == cloneID)   removeIndex <- duplicateRows[which.min(results$n[duplicateRows])]   rowsRemove <- c(rowsRemove, removeIndex) }  uniqueResults <- results[!c(1:nrow(results)) %in% rowsRemove, ] # Check that each unique clone now only appears once (no duplicates) stopifnot(all(table(uniqueResults$uniqueCloneID) == 1))"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-dataAnalysis.html","id":"mpn-vs--normal-fig--5e","dir":"Articles","previous_headings":"Downstream analysis > Recreating figures","what":"MPN vs. Normal (Fig. 5E)","title":"Analysis of human blood data","text":"Now, let’s take mean individual re-create Fig. 5E.","code":"# Get the unique individuals, and initialize vectors uniqueIndividuals <- unique(uniqueResults$patient) individualMeans <- c() malNorm <- c()  # Fill vectors with mean growth rate and MPN status of each individual for (ind in uniqueIndividuals) {   individualMeans <- c(individualMeans, mean(uniqueResults$estimate[uniqueResults$patient == ind]))   malNorm <- c(malNorm, uniqueResults$malnorm[uniqueResults$patient == ind][1]) }  # Combine results into a data.frame mal_vs_norm.df <- data.frame(   \"Patient\" = uniqueIndividuals,   \"meanEstimate\" = individualMeans,   \"malNorm\" = malNorm )  # Run a non-parametric Mann-whitney test to see if they're significantly different nonparamTest <- wilcox.test(meanEstimate ~ malNorm, data = mal_vs_norm.df) print(nonparamTest) #>  #>  Wilcoxon rank sum exact test #>  #> data:  meanEstimate by malNorm #> W = 64, p-value = 0.02853 #> alternative hypothesis: true location shift is not equal to 0  # Set factor ordering for plot and plot using ggplot (Fig. 5E) mal_vs_norm.df$malNorm <- factor(mal_vs_norm.df$malNorm, levels = c(\"Normal\", \"Malignant\")) ggplot(mal_vs_norm.df, aes(x = malNorm, y = meanEstimate)) +   geom_label(label = paste0(\"p = \", round(nonparamTest$p.value, 3)), x = 1.5, y = 1.2) +   geom_boxplot(width = 0.3, aes(color = malNorm), outlier.shape = NA) +   geom_jitter(aes(x = malNorm, y = meanEstimate, color = malNorm), width = .1, size = 2) +   scale_color_manual(values = c(\"black\", \"red\"), labels = c(\"Normal\", \"MPN\")) +   theme_bw() +   ylab(\"Mean net growth rate (r)\") +   xlab(\"\") +   theme(     legend.position = \"none\",     axis.ticks.x = element_blank(), axis.title.x = element_blank()   )"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-dataAnalysis.html","id":"single-vs--multi-driver-fig--5f","dir":"Articles","previous_headings":"Downstream analysis > Recreating figures","what":"Single vs. multi-driver (Fig. 5F)","title":"Analysis of human blood data","text":"Taking results unique clones, uniqueResults, let’s compare growth rates clones either unknown driver single driver, multiple drivers. , ’ll notice handy convention metadata: drivers separated “”, clone “” driver column, multiple drivers:","code":"# Set the multi driver variable according to whether multiple drivers are annotated uniqueResults$multiDriver <- \"Single or unknown\" uniqueResults$multiDriver[grepl(\"AND\", uniqueResults$cloneDriver)] <- \"Multiple\"  # Run a non-parametric test to see if the differences are significant nonParamTest <- wilcox.test(estimate ~ multiDriver, data = uniqueResults) print(nonParamTest) #>  #>  Wilcoxon rank sum exact test #>  #> data:  estimate by multiDriver #> W = 276, p-value = 1.554e-06 #> alternative hypothesis: true location shift is not equal to 0  # Set factor levels to control plot order uniqueResults$multiDriver <- factor(uniqueResults$multiDriver, levels = c(\"Single or unknown\", \"Multiple\"))  # Plot (Fig. 5F) ggplot(uniqueResults, aes(x = multiDriver, y = estimate)) +   geom_boxplot(width = 0.3, aes(color = multiDriver), outlier.shape = NA) +   geom_jitter(aes(x = multiDriver, y = estimate, color = multiDriver), width = .1) +   scale_color_manual(values = c(colorPal[4], colorPal[8])) +   theme_bw() +   geom_label(label = paste0(\"p=\", round(nonParamTest$p.value, 7)), x = 1.5, y = 2) +   ylab(\"Net growth rate (r)\") +   xlab(\"\") +   ggtitle(\"Driver mutations\") +   theme(     legend.position = \"none\", axis.ticks.x = element_blank(),     axis.title.x = element_blank(), plot.title = element_text(hjust = .5)   )"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-dataAnalysis.html","id":"time-from-clone-initiation-to-diagnosis-fig--5g","dir":"Articles","previous_headings":"Downstream analysis > Recreating figures","what":"Time from clone initiation to diagnosis (Fig. 5G)","title":"Analysis of human blood data","text":"discussed results data.frame (output internalLengths() maxLikelihood()) came clone age estimate, \\(1/r\\) + time sampling back first coalescence. birth rate clone \\(\\) death rate \\(b\\), net growth rate \\(r=-b\\). first coalescence represents first surviving division , neither offspring division die , ’ll account , average, half cells clone. means even sample 10 cells, ’re likely sample least one descendant two offspring, meaning first surviving division earliest coalescence, relative time sampling. know first surviving division occurs? Well, know: birth rate \\(\\) probability survival given individual \\((-b)/\\) \\(r/\\) leads rate surviving divisions equal \\(*r/= r\\). Therefore, expected waiting time clone initiation first surviving division \\(1/r\\). way, let’s see growth rate tells us anything time clone initiation diagnosis. , want use max. growth rate patient, ’s one ’d assume likely drive MPN initiation. don’t understand MPN well though, alternative use recently emerged clone prior diagnosis. ’ll , showing actually give results, probably clone arises later life must fit enough -compete clones already expanded. see 15/19 cases, youngest clone (>= 10 tips) also fit. First, let’s use fit clones stratify mean, reproducing result Figure 5G.  don’t fully understand clonal hematopoiesis MPN, ’s reasonable wonder whether using fittest clone best way compare time diagnosis. alternative, let’s compare youngest clones, seeing growth rate estimates still stratify time diagnosis. turns , youngest clone fittest clone 13 individuals diagnosed MPN. saw case 15 19 individuals including healthy individuals.","code":"# Get the clone IDs of the fittest clone in each patient cloneIDs_max <- sapply(unique(uniqueResults$patient), function(x) {   patient.df <- uniqueResults[uniqueResults$patient == x, ]   cloneID <- patient.df$cloneName_result[which.max(patient.df$estimate)]   cloneID })  # Get the clone IDs of the youngest clone in each patient cloneIDs_youngest <- sapply(unique(uniqueResults$patient), function(x) {   patient.df <- uniqueResults[uniqueResults$patient == x, ]   cloneID <- patient.df$cloneName_result[which.min(patient.df$cloneAgeEstimate)]   cloneID })  # See how much overlap there is between the most recent clone and the highest growth rate table(cloneIDs_max == cloneIDs_youngest) #>  #> FALSE  TRUE  #>     4    15 # Subset the results to only have the fittest clone for each patient maxResults <- uniqueResults[uniqueResults$cloneName_result %in% cloneIDs_max, ]  # Subset to the MPN patients malMax <- maxResults[maxResults$malnorm == \"Malignant\", ]  # Determine time from clone initiation to diagnosis malMax$latency_to_dx <- malMax$cloneAgeEstimate - (malMax$age - malMax$diagnosis.age)  # Stratify the population by the mean growth rate, adding a column \"aboveMean\" malMax$aboveMean <- malMax$estimate > mean(malMax$estimate)  # Use the survival package to see if differences are significant malMax$status <- 1 survivalTest <- survival::survdiff(survival::Surv(time = latency_to_dx, event = status) ~ aboveMean, data = malMax) print(survivalTest$pvalue) #> [1] 0.002628379  # Plot survival curves survfit2(Surv(time = latency_to_dx, event = status) ~ aboveMean, data = malMax) %>%   ggsurvfit() +   labs(     y = \"Probability diagnosis-free\",     x = \"Time from clone initiation (yrs.)\"   ) + scale_color_manual(values = c(colorPal[7], colorPal[3])) +   theme(legend.position = \"none\") +   geom_label(label = paste0(\"p = \", round(survivalTest$pvalue, 4)), x = 45, y = .85, color = \"black\", fill = \"white\") +   geom_label(label = \"r < mean\", x = 40, y = .375, color = colorPal[7], fill = \"white\") +   geom_label(label = \"r > mean\", x = 12, y = .35, color = colorPal[3], fill = \"white\") youngestResults <- uniqueResults[uniqueResults$cloneName_result %in% cloneIDs_youngest, ]  # Subset to the MPN patients malYoungest <- youngestResults[youngestResults$malnorm == \"Malignant\", ]  # Check how much overlap there is between youngest clone and fittest clone in the MPN dataset table(malYoungest$cloneName_result == malMax$cloneName_result) #>  #> TRUE  #>   13"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-dataAnalysis.html","id":"validation","dir":"Articles","previous_headings":"","what":"Validation","title":"Analysis of human blood data","text":"Remember said three cases duplicate clones? Well, estimates worth anything, must consistent. means , three clones, expect estimates similar timepoints. Let’s check :  bad! ’s good consistent, ’s better consistent accurate. , need completely orthogonal way measure clonal growth rates, comes longitudinal data. One clones Williams paper two clones Fabre paper matching longitudinal data. formatted nicely comes package! Let’s now fit logistic curve longitudinal data estimate growth rate one clones, individual PD9478, tree showed beginning vignette. , recreating analysis Figure 6.  Now, let’s see estimate compares maximum likelihood estimate:  , bad! result shown Figure 6 &D. now tools reproduce analysis relating real data aspect paper. Hopefully able matter hours minutes, much better months took !","code":"# Like before, we can find which clone IDs appear twice tmp <- table(results$uniqueCloneID) repeatsVec <- names(tmp)[tmp == 2]  # Subset the results to include only repeated clones repeatResults <- results[results$uniqueCloneID %in% repeatsVec, ]  # Plot the repeated clones ggplot(repeatResults) +   geom_pointrange(data = repeatResults, aes(     x = cloneName_result, y = estimate, ymin = lowerBound,     ymax = upperBound, color = uniqueCloneID   )) +   scale_color_manual(values = colorPal[c(1, 6, 7)]) +   theme_bw() +   ylab(\"Net growth rate estimate (r)\") +   theme(axis.text.x = element_blank(), axis.title.x = element_blank(), legend.title = element_blank()) # Get data from PD9478 PD9478_long <- longitudinalData[longitudinalData$Sample.ID == \"PD9478\", ]  # Get a rough estimate for starting params startingParams <- suppressWarnings(coef(lm(logit(VAF / .5) ~ Age, data = PD9478_long)))  # Fit to a three parameter logistic curve fit <- nls(VAF ~ K / (1 + exp(-(phi2 + r * Age))),   start = list(K = 0.2, phi2 = min(c(-0.000001, startingParams[1])), r = max(c(0.00001, startingParams[2]))),   data = PD9478_long, trace = FALSE, algorithm = \"port\", lower = c(0, -500, 0.00001), upper = c(0.5, 0, 5) )  # Set output equal to summary of longitudinal models output <- summary(fit)  # Assign fitted params r <- output$coefficients[\"r\", 1] t_m <- -output$coefficients[\"phi2\", 1] / r # Get midpoint time by dividing by -1/r K <- output$coefficients[\"K\", 1]  # Get CI for growth rate of longitudinal/logistic model stdError <- output$coefficients[\"r\", \"Std. Error\"] lb <- r - 1.96 * stdError ub <- r + 1.96 * stdError  # Prepare a df for plotting the fit line along with the data x <- c((min(PD9478_long$Age) - 10):(max(PD9478_long$Age) + 10)) # construct a range of x values bounded by the data y <- K / (1 + exp(-(x - t_m) * r)) # curve VAF (3 param model) predict.df <- data.frame(\"x\" = x, \"y\" = y)  # Set color for longitudinal fit info fitColor <- colorPal[6]  # Plot ggplot(PD9478_long, aes(x = Age, y = VAF)) +   theme_bw() +   coord_cartesian(xlim = c(min(x), max(x)), ylim = c(-0.01, 0.52), expand = 0) +   labs(x = \"Person Age (yr)\", y = \"Variant Allele Frequency (VAF)\") +   ggtitle(gsub(\"_\", \" & \", paste0(PD9478_long$Sample.ID[1], \" \", PD9478_long$Gene[1]))) +   geom_line(data = predict.df, aes(x = x, y = y), color = fitColor, linewidth = 1, show.legend = TRUE) +   geom_point(color = \"#808080\", shape = 18, size = 1.5) +   geom_vline(xintercept = t_m, linetype = \"dotted\", color = fitColor, linewidth = .6) +   geom_hline(yintercept = K, linetype = \"dotted\", color = fitColor, linewidth = .6) # Get the single cell estimate from PD9478 clone 1 scPD9478 <- results[results$cloneName_result == \"PD9478_1_clone1\", ]  # Combine orthogonal estimates into one df for plotting combine.df <- data.frame(   \"Clone\" = \"PD9478_1_clone1\",   \"r\" = c(r, scPD9478$estimate),   \"lowerBound\" = c(lb, scPD9478$lowerBound),   \"upperBound\" = c(ub, scPD9478$upperBound),   \"method\" = c(\"longitudinal\", \"max. likelihood\") )  # Plot ggplot(combine.df) +   geom_pointrange(aes(x = method, y = r, ymin = lowerBound, ymax = upperBound)) +   theme_bw() +   theme(axis.title.x = element_blank()) +   ylab(\"Net growth rate (r)\")"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-dataAnalysis.html","id":"references-data-sources","dir":"Articles","previous_headings":"","what":"References / Data sources:","title":"Analysis of human blood data","text":"real world data include produced annotated fascinating papers, advanced capabilities single-cell Whole Genome Sequencing. also provide excellent analysis addition provide work. Williams et al. 2022 Mitchell et al. 2022 Fabre et al. 2022 Van Egeren et al. 2021 mathematical methods estimating growth rates build large part work Amaury Lambert : Lambert, 2018 ’s final link paper details methods data analysis. enjoyed color palette plotting, tried use colorblind friendly colors, specifically pulling colors palette designed Bang Wong available .","code":""},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-simulate.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Intro to validating growth rate estimates via simulation","text":"First, ’ll load packages want use. ’ll plotting trees using ape package function ape::plot.phylo() along ape functions. cloneRate installed, already ape package. ’ll also using ggplot2 make plots, can installed CRAN. ’ll also set color palette ’ll use plotting. palette avilable .","code":"# Load and attach our package cloneRate library(cloneRate)  # Load and attach ape, which will be installed if you've installed cloneRate library(ape)  # Install ggplot2 from CRAN if necessary, then load and attach it with library() library(ggplot2) colorPal <- c(\"#000000\", \"#E69F00\", \"#56B4E9\", \"#009E73\", \"#F0E442\", \"#0072B2\", \"#D55E00\", \"#CC79A7\")"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-simulate.html","id":"simulating-trees","dir":"Articles","previous_headings":"","what":"Simulating trees","title":"Intro to validating growth rate estimates via simulation","text":"section, ’ll simulate ultrametric mutation-based trees. Ultrametric just means tips distance root. specific case, ultrametric trees edge lengths units time, ultrametric means tips sampled time. Mutation-based trees edge lengths units mutations. Mutation-based trees typically ultrametric, fluctuations number mutations acquired. ’ll generating trees class phylo, fairly straightforward encoding phylogenetic trees R. ape documentation describing class phylo can found .","code":""},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-simulate.html","id":"ultrametric-trees","dir":"Articles","previous_headings":"Simulating trees","what":"Ultrametric trees","title":"Intro to validating growth rate estimates via simulation","text":"Let’s start ultrametric trees. First, let’s simulate single tree look class phylo. ’ll use function simUltra() package , simulates ultrametric tree. ’ll set birth rate , death rate b, age tree cloneAge, number sampled tips n. Note use cloneAge instead \\(T\\) time T R means TRUE. , best place get info class phylo . functions simulating trees include metadata. Let’s take look metadata included tree. see columns : r, , b: growth rate params. r net growth rate, birth rate b death rate, r=-b cloneAge: time passes, units r, , b. n: number samples birth-death process, producing tree n tips. runtime_seconds: elapsed time generate tree. addStem: Tells us whether tree root edge preceding first split. ’ll show “stem” plots . Now let’s plot tree.  tree plotted , see “stem” edge extending time 0 first split. call splits coalescence events ’ll important methods growth rate estimation. Also, see tree ultrametric, meaning sampled time, case 20 units time birth-death process began. default, ’ll talk units time years, arbitrary. Just make sure units growth rate (per year) time units (years). Let’s apply growth rate estimates tree, seeing estimates close value r used generate tree. two functions estimating growth rate ultrametric tree, ’ll compare performance later : internalLengths(): function sums edge lengths internal edges tree (excluding stem). call sum \\(L_i\\). growth rate calculated \\(r = L_i / n\\) \\(n\\) number sampled tips. maxLikelihood(): function uses maximum likelihood estimation distribution coalescence times, using information tree splits. distribution coalescence times approximated standard logistic distribution scaled \\(1/r\\). Maximizing likelihood observed coalescence times \\(r\\) term gives us estimate. methods detailed paper. know actual growth rate 1, can evaluate estimates . One estimate doesn’t really tell us much though. Let’s try 100. , just set nTrees param equal 100 simUltra() function. can parallelize process parallel package installed simply setting nCores, ’ll leave 1 now. printing elapsed time, see one core takes minute. Let’s apply methods trees. can input either single phylo object, list phylo objects growth rate functions. Either way, ’ll return data.frame row corresponding estimate tree. gave method 100 trees estimate, let’s plot estimates. Remember input trees growth rate 1, want estimates close 1. ’ll use ggplot’s density plot :  bad, ’ll want test formally large range parameter values. later vignette. now, let’s shift attention mutation trees.","code":"# Generate the tree tree <- simUltra(a = 1, b = 0, cloneAge = 20, n = 100, addStem = TRUE)  # We see that the tree is of class phylo class(tree) #> [1] \"phylo\"  # Preview the tree print(tree) #>  #> Phylogenetic tree with 100 tips and 100 internal nodes. #>  #> Tip labels: #>   t52, t90, t20, t28, t48, t34, ... #>  #> Rooted; includes branch lengths. print(tree$metadata) #>   r a b cloneAge   n runtime_seconds addStem #> 1 1 1 0       20 100           1.211    TRUE plot.phylo(tree, direction = \"downwards\", show.tip.label = FALSE) axisPhylo(side = 2, backward = FALSE, las = 1) title(main = \"Simulated tree\", ylab = \"Time\") maxLikelihood(tree)$estimate #> [1] 1.024646  internalLengths(tree)$estimate #> [1] 1.097065 ptm <- proc.time() tree.list <- simUltra(a = 1, b = 0, cloneAge = 20, n = 100, nTrees = 100, nCores = 1, addStem = TRUE) print(proc.time()[[\"elapsed\"]] - ptm[[\"elapsed\"]]) #> [1] 106.605 resultsMaxLike <- maxLikelihood(tree.list)  resultsLengths <- internalLengths(tree.list) # Combine for ggplot formatting resultsCombined <- rbind(resultsLengths, resultsMaxLike)  # Plot, adding a vertical line at r=1 because that's the true growth rate ggplot(resultsCombined) +   geom_density(aes(x = estimate, color = method), linewidth = 1.5) +   geom_vline(xintercept = exampleUltraTrees[[1]]$metadata$r) +   theme_bw() +   theme(     axis.text.y = element_blank(), axis.ticks.y = element_blank(),     legend.title = element_blank()   ) +   xlab(\"Net growth rate estimate (r)\") +   ylab(\"Density\") +   scale_color_manual(labels = c(\"Internal lengths\", \"Max. likelihood\"), values = c(\"black\", \"#009E73\"))"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-simulate.html","id":"mutation-trees","dir":"Articles","previous_headings":"Simulating trees","what":"Mutation trees","title":"Intro to validating growth rate estimates via simulation","text":"two ways generate mutation trees: can add mutations time-based ultrametric tree can generate completely new mutation-based tree Either way, process generating mutation trees consists : Generating ultrametric, time-based tree. step required generate new tree edge, draw number mutations poisson distribution mean equal mutation rate nu multiplied edge length time-based tree. Let’s take ultrametric trees just generated convert mutation-based trees. , provide function ultra2mut(): Alternatively, can generate new set mutation trees using function simMut(). won’t run take another minutes, already mutation-based trees generated . want estimate growth rate mutation tree, use sharedMuts() function, works similarly internalLengths() function. However, instead counting internal edge lengths units time, sharedMuts() function counts internal/shared mutations uses mutation rate scale time. , \\(M_i\\) number internal shared mutations, \\(\\nu\\) (nu) mutation rate, \\(n\\) number samples, growth rate estimate \\(r = M_i /(\\nu n)\\). Let’s apply sharedMuts() function trees converted mutation-based. Remember mutation-based trees generated ultrametric trees applied functions maxLikelihood() internalLengths() . Let’s plot estimates together. First, ’ll combine data.frames produced. sharedMuts() function outputs additional column corresponding mutation rate nu. , using rbind full data.frames give error. want look estimates now, ’ll just combine necessary columns data.frame.  looks like ’re right track. , ’s hard tell best. Maximum likelihood seems bit biased high side, estimates seem fall narrow range. Let’s quantitative analysis now hang .","code":"# Set mutation rate equal to 10 muts/year for all trees mutTree.list <- ultra2mut(tree.list, nu = 10) # Set params for ultra tree + a mutation rate mutTree.list2 <- simMut(a = 1, b = 0, cloneAge = 20, n = 100, nTrees = 100, nu = 100, nCores = 1) resultsShared <- sharedMuts(mutTree.list, nu = 10) # Combine the columns with the estimates colsUse <- c(\"lowerBound\", \"estimate\", \"upperBound\", \"method\") resultsAll <- rbind(resultsShared[, colsUse], resultsCombined[, colsUse])  # Plot, adding a vertical line at r=1 because that's the true growth rate ggplot(resultsAll) +   geom_density(aes(x = estimate, color = method), linewidth = 1.5) +   geom_vline(xintercept = exampleUltraTrees[[1]]$metadata$r) +   theme_bw() +   theme(     axis.text.y = element_blank(), axis.ticks.y = element_blank(),     legend.title = element_blank()   ) +   xlab(\"Net growth rate estimate (r)\") +   ylab(\"Density\") +   scale_color_manual(labels = c(\"Internal lengths\", \"Max. likelihood\", \"Shared Muts.\"), values = c(colorPal[1], colorPal[4], colorPal[6]))"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-simulate.html","id":"quantitative-comparisons","dir":"Articles","previous_headings":"","what":"Quantitative comparisons","title":"Intro to validating growth rate estimates via simulation","text":"section, ’ll use ability generate trees order test methods. ’ll focus mainly ultrametric trees, noting mutation-based approach based shared mutations analogous internal lengths method. ’ll see well methods perform, perform well, fail.","code":""},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-simulate.html","id":"max-likelihood-vs--internal-lengths-vs--shared-mutations","dir":"Articles","previous_headings":"Quantitative comparisons","what":"Max likelihood vs. internal lengths vs. shared mutations","title":"Intro to validating growth rate estimates via simulation","text":"want know estimate best. ’ll start making quantiative comparison 100 estimates already simulations previous section. 100 trees enough get idea estimate accurate, can always simulate . won’t though ’ll take bit longer , well, stop somewhere.","code":""},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-simulate.html","id":"root-mean-square-error-rmse","dir":"Articles","previous_headings":"Quantitative comparisons > Max likelihood vs. internal lengths vs. shared mutations","what":"Root Mean Square Error (RMSE)","title":"Intro to validating growth rate estimates via simulation","text":"","code":"# Calculate the RMSE groundTruth <- 1 rmse <- unlist(lapply(   split(resultsAll, resultsAll$method),   function(x) {     sqrt(sum((x$estimate - groundTruth)^2) / length(x$estimate))   } ))  print(rmse) #>    lengths    maxLike sharedMuts  #>  0.1018684  0.1109116  0.1142390"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-simulate.html","id":"mean","dir":"Articles","previous_headings":"Quantitative comparisons > Max likelihood vs. internal lengths vs. shared mutations","what":"Mean","title":"Intro to validating growth rate estimates via simulation","text":"","code":"# Calculate the mean simMean <- unlist(lapply(   split(resultsAll, resultsAll$method),   function(x) {     mean(x$estimate)   } ))  print(simMean) #>    lengths    maxLike sharedMuts  #>   1.037186   1.067219   1.042052"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-simulate.html","id":"standard-deviation","dir":"Articles","previous_headings":"Quantitative comparisons > Max likelihood vs. internal lengths vs. shared mutations","what":"Standard deviation","title":"Intro to validating growth rate estimates via simulation","text":"saw density plot quantified mean, sd, rmse. Maximum likelihood usually performs best Root Mean Square Error (RMSE) even though ’s mean bit higher (usually around 1.04). 100 trees, larger fluctuations, maximum likelihood might higher RMSE methods. shared mutations method typically performs bit worse ultrametric cousin, internalLengths(). randomness poissonian mutation accumulation likely leads wider spread estimates sharedMuts(), explains difference two methods.","code":"# Calculate the standard deviation of our estimates simSD <- unlist(lapply(   split(resultsAll, resultsAll$method),   function(x) {     sd(x$estimate)   } ))  print(simSD) #>    lengths    maxLike sharedMuts  #> 0.09531642 0.08866603 0.10675267"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-simulate.html","id":"coverage-probability","dir":"Articles","previous_headings":"Quantitative comparisons > Max likelihood vs. internal lengths vs. shared mutations","what":"Coverage probability","title":"Intro to validating growth rate estimates via simulation","text":"now, ’ve looked estimate . note methods also provide confidence intervals. default, alpha = 0.05, provide 95% confidence intervals. can change ’d like, 95% seems pretty standard, ’ll use . 95% confidence interval accurate, ’d expect ground truth growth rate fall within confidence interval 95% time. Let’s check: ’re right around 95%, great! might expect maxLikelihood(), typically lowest RMSE, might best coverage probability. fact, confidence interval maxLikelihood() function narrower. opposite true sharedMuts() widest confidence interval account randomness mutation accumulation. 100 trees, coverage probability rough estimate.","code":"# Calculate the coverage probability of our estimates groundTruth <- 1 simCoverage <- unlist(lapply(   split(resultsAll, resultsAll$method),   function(x) {     # Set insideInterval to TRUE if inside interval and FALSE if outside     insideInterval <- (x$lowerBound < groundTruth & x$upperBound > groundTruth)     # Count TRUE as 1 and FALSE as 0. See the fraction inside interval     sum(insideInterval) / length(insideInterval)   } ))  print(simCoverage) #>    lengths    maxLike sharedMuts  #>       0.98       0.90       0.98"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-simulate.html","id":"varying-parameters","dir":"Articles","previous_headings":"","what":"Varying parameters","title":"Intro to validating growth rate estimates via simulation","text":"far, ’ve looked parameters. Now, ’ll see happens change important parameters birth-death process.","code":""},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-simulate.html","id":"varying-n","dir":"Articles","previous_headings":"Varying parameters","what":"Varying n","title":"Intro to validating growth rate estimates via simulation","text":"One interesting results explore accuracy estimates depends number samples. , ’ll look different n parameter values. keep things running long, can re-use trees n=100 add 100 trees different n values. , let’s show run simUltra() vector input n. First, ’ll generate vector, ’ll call n_vec. Let’s explore small n value, 10, intermediate n value, 30. now, ’ll keep growth rate - b equal 1, ’ll let actual birth death rates vary. total, n_vec length 200. ’ll want make sure a_vec b_vec also length 200. ’ll set nTrees = 200. generate multiple trees, either set single value parameters, vector length nTrees. applies simUltra() simMut(). Let’s generate trees. Note: also take minute two. Now, let’s apply estimates combine data.frames: Finally, can add resultsCombined data.frame , results applying maxLikelihood() internalLengths() set 100 ultrametric trees n = 100. Let’s make plot , showing performance. ’ll use ggplot2::facet_wrap() order show plot various n values. Although different number trees n = 100 case, density plot normalize .  can see, estimates highly dependent number samples. ’d like see density values y-axis three n values, set scales = \"fixed\" facet_wrap() function. ’re interested, can apply quantitative measures data Quantitative comparisons. won’t repeat , show Figure 2 paper. information also available Supplementary tables, also available .csv files.","code":"n_vec <- c(rep(10, 100), rep(30, 100)) a_vec <- stats::runif(n = 200, min = 1, max = 4) b_vec <- a_vec - 1 n10_n30_trees <- simUltra(   a = a_vec, b = b_vec, cloneAge = 20, n = n_vec,   nTrees = length(n_vec) ) # Apply our estimates for ultrametric trees n10_n30_maxLike <- maxLikelihood(n10_n30_trees) n10_n30_lengths <- internalLengths(n10_n30_trees)  # Combine the estimates n10_n30_both <- rbind(n10_n30_maxLike, n10_n30_lengths) # Merge the results data.frames results_vary_n <- rbind(n10_n30_both, resultsCombined) ggplot(results_vary_n) +   geom_density(aes(x = estimate, color = method), linewidth = 1.5) +   geom_vline(xintercept = exampleUltraTrees[[1]]$metadata$r) +   theme_bw() +   theme(     axis.text.y = element_blank(), axis.ticks.y = element_blank(),     legend.title = element_blank()   ) +   xlim(0, 3) +   xlab(\"Net growth rate estimate (r)\") +   ylab(\"Density\") +   scale_color_manual(     labels = c(\"Internal lengths\", \"Max. likelihood\"),     values = c(\"black\", \"#009E73\")   ) +   facet_wrap(~ factor(paste0(\"n = \", n), levels = c(\"n = 10\", \"n = 30\", \"n = 100\")),     ncol = 1, strip.position = \"bottom\", scales = \"free\", dir = \"v\"   ) #> Warning: Removed 4 rows containing non-finite values (`stat_density()`)."},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-simulate.html","id":"varying-r-andor-cloneage","dir":"Articles","previous_headings":"Varying parameters","what":"Varying r (and/or cloneAge)","title":"Intro to validating growth rate estimates via simulation","text":"noted , can simulate many trees using simUltra() simMut(). , ’ll use simUltra() generate 100 trees various growth rates. similar analysis Figures 3 4 paper, noting methods struggle small growth rates. Let’s see come conclusion .","code":""},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-simulate.html","id":"varying-r-or-cloneage","dir":"Articles","previous_headings":"Varying parameters > Varying r (and/or cloneAge)","what":"Varying r or cloneAge?","title":"Intro to validating growth rate estimates via simulation","text":"First, address something might otherwise lead confusion; varying r varying cloneAge. think , makes sense. simulate population net growth rate 1 per year 20 years look growth rate 0.5 per year 40 years. ’ll show , first consider fact units meaningless, long ’re consistent. growth rate 1/12 clone age 20*12 exactly growth rate 1 20 units change years months. might bit confusing, let’s plot . First, ’ll simulate tree growth rate 2 30 years compare tree growth rate 0.5 30 years. trees look different. Finally, ’ll add tree growth rate 0.5, run 120 years. said true, see last tree looks like first tree, 0.5 120 2 30. Let’s find : Now, let’s plot using par() show three one plot  trees left right aren’t identical due stochastic nature birth-death process, similar, certainly different tree middle.","code":"# First tree, r = a - b = 2 tree1 <- simUltra(a = 2.5, b = .5, cloneAge = 30, n = 50)  # Second tree, with r = a - b = 0.5 tree2 <- simUltra(a = 1, b = .5, cloneAge = 30, n = 50)  # Third tree, with r = 0.5 but cloneAge = 120 tree3 <- simUltra(a = 1, b = .5, cloneAge = 120, n = 50) oldpar <- graphics::par(mfrow = c(1, 3)) ape::plot.phylo(tree1, direction = \"downwards\", show.tip.label = F, main = \"r = 2, cloneAge = 30\") ape::plot.phylo(tree2, direction = \"downwards\", show.tip.label = F, main = \"r = 0.5, cloneAge = 30\") ape::plot.phylo(tree3, direction = \"downwards\", show.tip.label = F, main = \"r = 0.5, cloneAge = 120\") # reset par settings graphics::par(oldpar)"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-simulate.html","id":"performance-across-r-values","dir":"Articles","previous_headings":"Varying parameters > Varying r (and/or cloneAge)","what":"Performance across r values","title":"Intro to validating growth rate estimates via simulation","text":"Now can arbitrarily choose whether vary r cloneAge. consistency, ’ll vary r, Figures 3 4 paper. , two options: Simulate fixed r values, showing good problematic Simulate random r values try decipher estimates good aren’t Option 1 essentially Varying n, r instead n, repeating wouldn’t useful. Option 2 also realistic…can pretend don’t know ground truth show decide methods relevant comparing ground truth. Let’s simulate 1000 trees 50 samples n various growth rates r, ranging 0.1 1 per year, run 40 years. take , won’t actually evaluate part vignette. However, full reproduction work recent paper article, “Reproduce simulation results” can found package website. run code , analyze done, internalLengths() maxLikelihood() functions. However, ’d also apply diagnostic, tells us clones good candidates method, . run clone ’s good candidate, ’ll get warning. Let’s generate tree low growth rate plot .  see tree long internal branches short external branches. indicates process “supercritical” enough (.e. growth rate time low). Quantitatively, means ratio external internal edge lengths low. Let’s try apply methods: estimates quite bit (ground truth estimate 0.1), see warning. warning tells us external internal edge length ratio 3, clone likely good candidate methods. details came 3 cutoff see Figure 4 paper reproduced analysis article, “Reproduce simulation results” package website. real advantage diagnostic can look tree calculate ratio tell us right away methods applicable. , ’re interested quantitative side , can apply metrics Quantitative comparisons section, longer form analysis article mentioned .","code":"# Uniform ditribution of r used to generate b_vec r_vec <- stats::runif(n = 1000, min = 0.1, max = 1) a_vec <- stats::runif(n = 1000, min = 1, max = 3) b_vec <- a_vec - r_vec  # Input to simUltra() vary_r_trees <- simUltra(a = a_vec, b = b_vec, cloneAge = 40, n = 50, nTrees = length(a_vec)) # Let's call it slowClone slowClone <- simUltra(a = .15, b = .05, n = 50, cloneAge = 40)  # Plot the tree ape::plot.phylo(slowClone, direction = \"downwards\", show.tip.label = F) # Apply our estimates maxLikelihood(slowClone) #> Warning in maxLikelihood(slowClone): External to internal lengths ratio is less than or equal to 3, #>             which means max. likelihood method may not be applicable. Consider #>             using birthDeathMCMC() function, which avoids this issue. #>   lowerBound  estimate upperBound cloneAgeEstimate sumInternalLengths #> 1  0.1948589 0.2536544  0.3124499         28.84651           214.0329 #>   sumExternalLengths extIntRatio  n alpha runtime_s  method #> 1           258.6408    1.208416 50  0.05     0.006 maxLike internalLengths(slowClone) #> Warning in internalLengths(slowClone): External to internal lengths ratio is less than or equal to 3, #>             which means internal lengths method may not be applicable. Consider #>             using birthDeathMCMC() function, which avoids this issue. #>   lowerBound  estimate upperBound cloneAgeEstimate sumInternalLengths #> 1   0.168857 0.2336089  0.2983608         29.18479           214.0329 #>   sumExternalLengths extIntRatio  n alpha runtime_s  method #> 1           258.6408    1.208416 50  0.05     0.003 lengths"},{"path":"https://bdj34.github.io/cloneRate/articles/cloneRate-simulate.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Intro to validating growth rate estimates via simulation","text":"method simulating trees direct result work Amaury Lambert following paper. mathematical methods estimating growth rates build large part work, linked : Lambert, 2018 ’s final link paper details methods data analysis. aren’t many colors vignette, tried use colorblind friendly colors, specifically pulling colors palette designed Bang Wong available .","code":""},{"path":"https://bdj34.github.io/cloneRate/articles/reproduce-simResults.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Reproduce simulation results","text":"First, ’ll load packages want use. ’ll plotting trees using ape package function ape::plot.phylo() along ape functions. cloneRate installed, already ape package. ’ll also using ggplot2 make plots, can installed CRAN shown : ’ll also set color palette ’ll use plotting. palette taken ","code":"# Load and attach our package cloneRate library(cloneRate)  # Load and attach ape, which will be installed if you've installed cloneRate library(ape)  # Load and attach rstan, which is necessary for running MCMC's (birthDeathMCMC() and Phylofit) library(rstan)  # Load and attach the parallel package, which is not strictly necessary for running MCMC's, but greatly reduces the time required and is necessary for executing code in this article. library(parallel)  # Install ggplot2 if necessary, then load and attach it with library() # install.packages(\"ggplot2\") library(ggplot2) colorPal <- c(\"#000000\", \"#E69F00\", \"#56B4E9\", \"#009E73\", \"#F0E442\", \"#0072B2\", \"#D55E00\", \"#CC79A7\")"},{"path":"https://bdj34.github.io/cloneRate/articles/reproduce-simResults.html","id":"phylofit-setup","dir":"Articles","previous_headings":"Setup","what":"Phylofit setup","title":"Reproduce simulation results","text":"applying Phylofit, developed Nicholas Williams applied Williams et al. Mitchell et al., see Emily Mitchell’s github: https://github.com/emily-mitchell/normal_haematopoiesis/blob/main/1_functions/farm_only/phylofit.R. reproducibility, ’ll include code Emily Mithcell’s github slightly simplified form, don’t want apply Aberrant Cell Fraction (ACF) implementation Phylofit, reasons detailed paper. implement Phylofit Rstan, similar manner birth-death MCMC. First, compile Stan code: Now Stan code compiled, ’s ready run. ’ll wrap function similar functions estimating growth rate. ’ve made cosmetic changes, nothing affect Phylofit (ACF) output estimated growth rate:","code":"stan.code <- \"functions{ real glogistic_lpdf(real[] t, real S, real tm, real T,real N){ int n; real ll; n=size(t); ll=0.0; for(k in 2:n){ ll=ll+log(1+exp(S*(t[k-1]-T+tm))); ll=ll-(1/(S*N))*choose(k,2)*exp(-S*(T-tm-t[k]))*(exp(S*(t[k-1]-t[k]))-1); ll=ll+choose(k,2)*(t[k]-t[k-1])/N+log(choose(k,2))-log(N); } return(ll); } } data{ int N;      //number of tips in the tree real t[N];  //timing of coalescences (with an added, unused zero) real T; real maxT; real minT; real maxLN; real minLN; } parameters { real<lower=0.0001,upper=4> S; //instantaneous growth rate-> exp(S)-1 per Year. real <lower=minT,upper=maxT> tm; //midpoint real<lower=minLN,upper=maxLN> LN; //log (base 10) pop size (i.e. carrying capacity) } model { S ~ uniform(0.001,4); tm ~ uniform(minT,maxT); LN ~ uniform(minLN,maxLN); t ~ glogistic(S,tm,T,pow(10,LN)); } \" PHYLOFIT_STAN_MODEL <- stan_model(model_code = stan.code, model_name = \"Phylofit\") # Note that this will only work for binary trees phylofit <- function(ultratree, nChain = 3, nCores = 1, minLN = 4, maxLN = 7,                      chainLength = 20000, alpha = 0.05) {   ptm <- proc.time()    # Get data from the tree   coal_times <- sort(ape::branching.times(ultratree), decreasing = T)   dat <- list(     \"N\" = ape::Ntip(ultratree),     \"t\" = as.numeric(c(coal_times, 0)),     \"T\" = max(coal_times),     \"maxT\" = 2 * max(coal_times),     \"minLN\" = minLN, \"maxLN\" = maxLN   )   dat$minT <- as.numeric(dat$T - dat$t[1])    # Run the Stan code   stanr <- sampling(PHYLOFIT_STAN_MODEL,     data = dat, iter = chainLength, control = list(adapt_delta = 0.95),     chains = nChain, cores = nCores   )    # Return the results   ptile <- c(alpha / 2, .5, 1 - alpha / 2)   posterior <- quantile(rstan::extract(stanr)$S, ptile)   data.frame(     \"lowerBound\" = posterior[1], \"estimate\" = posterior[2],     \"upperBound\" = posterior[3], \"runtime_s\" = (proc.time() - ptm)[\"elapsed\"],     \"n\" = ape::Ntip(ultratree), \"alpha\" = alpha, \"method\" = \"Phylofit no ACF\",     \"nChains\" = nChain, \"nCores\" = nCores, \"chainLength\" = chainLength   ) }"},{"path":"https://bdj34.github.io/cloneRate/articles/reproduce-simResults.html","id":"varying-parameters","dir":"Articles","previous_headings":"","what":"Varying parameters","title":"Reproduce simulation results","text":"far, ’ve looked parameters. Now, ’ll see happens change important parameters birth-death process.","code":""},{"path":"https://bdj34.github.io/cloneRate/articles/reproduce-simResults.html","id":"varying-n","dir":"Articles","previous_headings":"Varying parameters","what":"Varying n","title":"Reproduce simulation results","text":"One interesting results explore accuracy estimates depends number samples. , ’ll look different n parameter values. can run simUltra() vector input n. First, ’ll generate vector, ’ll call n_vec. Keeping paper, ’ll produce 500 trees value n: keep growth rate - b equal 0.5, let actual birth death rates vary. total, n_vec length 3000. ’ll want make sure a_vec b_vec also length 3000. ’ll set nTrees = 3000. generate multiple trees, must either set single value parameters, vector length nTrees. applies simUltra() simMut(). Let’s generate trees. Note: take minutes, can parallelized setting nCores > 1. Now, let’s apply estimates combine data.frames: Let’s make plot , showing performance. ’ll use ggplot2::facet_wrap() order show plot various n values.  can see, estimates highly dependent number samples. ’d like see density values y-axis n values, set scales = \"fixed\" facet_wrap() function.","code":"n_vec <- rep(c(10, 30, 50, 100, 200, 500), each = 500) a_vec <- stats::runif(n = length(n_vec), min = 0.5, max = 1.5) b_vec <- a_vec - 0.5 vary_n_trees <- simUltra(   a = a_vec, b = b_vec, cloneAge = 40, n = n_vec,   nTrees = length(n_vec), nCores = 6 ) # Apply our estimates for ultrametric trees vary_n_maxLike <- suppressWarnings(maxLikelihood(vary_n_trees)) vary_n_lengths <- internalLengths(vary_n_trees)  # Combine the estimates vary_n_analytical <- rbind(vary_n_maxLike, vary_n_lengths) ggplot(vary_n_analytical) +   geom_density(aes(x = estimate, color = method), linewidth = 1) +   geom_vline(xintercept = 0.5) +   theme_bw() +   theme(     axis.text.y = element_blank(), axis.ticks.y = element_blank(),     legend.title = element_blank()   ) +   xlim(0, 3) +   xlab(\"Net growth rate estimate (r)\") +   ylab(\"Density\") +   scale_color_manual(     labels = c(\"Internal lengths\", \"Max. likelihood\"),     values = c(\"black\", colorPal[4])   ) +   facet_wrap(~ factor(paste0(\"n = \", n), levels = paste0(\"n = \", unique(n_vec))),     ncol = 1, strip.position = \"bottom\", scales = \"free\", dir = \"v\"   )"},{"path":"https://bdj34.github.io/cloneRate/articles/reproduce-simResults.html","id":"markov-chain-monte-carlo-mcmc-application","dir":"Articles","previous_headings":"Varying parameters > Varying n","what":"Markov Chain Monte Carlo (MCMC) application","title":"Reproduce simulation results","text":"Note: computationally intensive! Recommended run high performance computing environment. paper, show two alternatives, set advantages drawbacks. drawback MCMC approaches computational expense greatly increased compared internalLengths() maxLikelihood() estimates. Phylofit additional drawback overly confident confidence intervals, 95% Highest Posterior Density (HPD) doesn’t capture true value 95% time. deterministic approximation population size trajectory Phylofit doesn’t match stochastic underlying birth-death process generates simulated trees. birthDeathMCMC() approach doesn’t suffer drawback. MCMC approaches, added computational expense comes notable benefit. methods require birth-death process supercritical, work well even small growth rates. show section Varying r (/cloneAge). Phylofit additional drawback, also increased flexibility. Phylofit work well estimating growth rate even coalescence times characteristic logistic clonal growth trajectory. cases, number samples small enough effective population size large enough coalescence times date back exponential phase, carrying capacity logistic growth (saturating growth) affect coalescence times, case, constant birth-death approximations (birthDeathMCMC(), maxLikelihood(), internalLengths()) work well. run MCMC’s. include birth-death MCMC part cloneRate package, ’s straightforward one-liner: Phylofit, use phylofit() function created start, copy function Emily Mitchell’s github created Nick Williams used Williams et al. Mitchell et al. Now can make list set 500 trees, split method number samples, n.","code":"# NOTE: depending on the number of cores, this will take hours to days vary_n_bdMCMC <- birthDeathMCMC(vary_n_trees,   nCores = 3, nChains = 3,   chainLength = 15000, verbose = FALSE ) # NOTE: depending on the number of cores, this will take hours to days vary_n_phylofit <- do.call(   rbind,   mclapply(vary_n_trees, phylofit,     mc.cores = 5, mc.silent = TRUE   ) ) # Make a list with each list element containing a data.frame of results for a # given n and method vary_n_results <- unlist(   list(     split(vary_n_lengths, vary_n_lengths$n),     split(vary_n_maxLike, vary_n_maxLike$n),     split(vary_n_bdMCMC, vary_n_bdMCMC$n),     split(vary_n_phylofit, vary_n_phylofit$n)   ),   recursive = FALSE )"},{"path":"https://bdj34.github.io/cloneRate/articles/reproduce-simResults.html","id":"summary-statistics","dir":"Articles","previous_headings":"Varying parameters > Varying n","what":"Summary statistics","title":"Reproduce simulation results","text":"can write basic function give us summary statistics want estimates. Make sure input data.frame contains number tips, true growth rate, method, etc. combined. can apply summary stats function list results contained vary_n_results get summary data.frame statistics value n method. information summary_n.df available Supplementary table 6 paper, also available “.csv” file. Note stochastic nature tree generation MCMCs lead slight differences results time analysis performed.","code":"get_summary_stats <- function(df, growthRate, cloneAge) {   meanEstimate <- mean(df$estimate)   sdEstimate <- stats::sd(df$estimate)   medianEstimate <- stats::median(df$estimate)   normalizedRMSE <- sqrt(sum(((growthRate - df$estimate) / growthRate)^2) / nrow(df))   coverageProb <- sum(df$lowerBound < growthRate & df$upperBound > growthRate) / nrow(df)   runtimeMean <- mean(df$runtime_s)   runtimeSD <- stats::sd(df$runtime_s)   method <- unique(df$method)   nCores <- if (is.null(df$nCores[1])) {     1   } else {     df$nCores[1]   }   nChains <- if (is.null(df$nChains[1])) {     NA   } else {     df$nChains[1]   }   nTips <- unique(df$n)    # Combine everything into a data.frame to return   data.frame(     \"Method\" = method, \"Number of samples, n\" = nTips,     \"Net growth rate, r\" = growthRate, \"Clone age, T\" = cloneAge,     \"Number of simulated trees\" = nrow(df),     \"Mean estimate\" = meanEstimate, \"SD estimate\" = sdEstimate,     \"Median Estimate\" = medianEstimate,     \"Normalized RMSE\" = normalizedRMSE,     \"95% Coverage probability\" = coverageProb, # Assuming 95% CI     \"Runtime (s)\" = paste0(round(runtimeMean, 3), \" +/- \", round(runtimeSD, 3)),     \"Number of cores\" = nCores, \"Number of chains\" = nChains   ) } summary_n.df <- do.call(rbind, lapply(vary_n_results, get_summary_stats,   growthRate = 0.5, cloneAge = 40 ))"},{"path":"https://bdj34.github.io/cloneRate/articles/reproduce-simResults.html","id":"varying-r-andor-cloneage","dir":"Articles","previous_headings":"Varying parameters","what":"Varying r (and/or cloneAge)","title":"Reproduce simulation results","text":", ’ll recreate analysis Figures 3 4 paper, noting methods struggle small growth rates.","code":""},{"path":"https://bdj34.github.io/cloneRate/articles/reproduce-simResults.html","id":"varying-r-or-cloneage","dir":"Articles","previous_headings":"Varying parameters > Varying r (and/or cloneAge)","what":"Varying r or cloneAge?","title":"Reproduce simulation results","text":"First, address something might otherwise lead confusion; varying r varying cloneAge. simulate population net growth rate 1 per year 20 years look growth rate 0.5 per year 40 years. ’ll show , first consider fact units meaningless, long ’re consistent. growth rate 1/12 clone age 20*12 growth rate 1 20 units change years months. might bit confusing, let’s plot . First, ’ll simulate tree growth rate 2 30 years compare tree growth rate 0.5 30 years. trees look different. Finally, ’ll add tree growth rate 0.5, run 120 years. said true, see last tree looks like first tree, 0.5 120 2 30. Let’s find : Now, let’s plot using par() show three one plot  trees left right aren’t identical due stochastic nature birth-death process, similar, certainly different tree middle. note slight differences distribution coalescence times due different birth death rates (.e. different extinction probabilities), differences small enough negligible.","code":"# First tree, r = a - b = 2 tree1 <- simUltra(a = 2.5, b = .5, cloneAge = 30, n = 50)  # Second tree, with r = a - b = 0.5 tree2 <- simUltra(a = 1, b = .5, cloneAge = 30, n = 50)  # Third tree, with r = 0.5 but cloneAge = 120 tree3 <- simUltra(a = 1, b = .5, cloneAge = 120, n = 50) oldpar <- graphics::par(mfrow = c(1, 3)) ape::plot.phylo(tree1, direction = \"downwards\", show.tip.label = F, main = \"r = 2, cloneAge = 30\") ape::plot.phylo(tree2, direction = \"downwards\", show.tip.label = F, main = \"r = 0.5, cloneAge = 30\") ape::plot.phylo(tree3, direction = \"downwards\", show.tip.label = F, main = \"r = 0.5, cloneAge = 120\") # Reset par settings graphics::par(oldpar)"},{"path":"https://bdj34.github.io/cloneRate/articles/reproduce-simResults.html","id":"performance-across-r-values","dir":"Articles","previous_headings":"Varying parameters > Varying r (and/or cloneAge)","what":"Performance across r values","title":"Reproduce simulation results","text":"Now can arbitrarily choose whether vary r cloneAge. consistency, ’ll vary r, Figures 3 4 paper. , two analyses: Simulate fixed r values, showing good problematic Simulate random r values try decipher estimates good aren’t","code":""},{"path":"https://bdj34.github.io/cloneRate/articles/reproduce-simResults.html","id":"set-r-fig--3","dir":"Articles","previous_headings":"Varying parameters > Varying r (and/or cloneAge) > Performance across r values","what":"Set r (Fig. 3)","title":"Reproduce simulation results","text":"essentially Varying n, r instead n, can run quickly. First, generate trees, n=100 tips age 40 years, vary growth rate, 0.15 1. , keep growth rate - b equal r, let actual birth death rates vary. Now apply methods estimating growth rate: chunk suppress warnings related diagnostic tells us whether methods applicable. discuss [Random r]. NOTE: , running MCMC methods many times computationally expensive done high performance computing environment:","code":"r_vec <- rep(c(0.15, 0.2, 0.25, 0.5, 0.75, 1), each = 500) a_vec <- stats::runif(n = length(r_vec), min = r_vec, max = r_vec + 1) b_vec <- a_vec - r_vec  vary_r_trees <- simUltra(   a = a_vec, b = b_vec, cloneAge = 40, n = 100,   nTrees = length(a_vec), nCores = 6 ) # Apply our fast estimates (computationally cheap) vary_r_lengths <- suppressWarnings(internalLengths(vary_r_trees)) vary_r_maxLike <- suppressWarnings(maxLikelihood(vary_r_trees)) # NOTE: depending on the number of cores, these will take hours to days vary_r_bdMCMC <- birthDeathMCMC(vary_r_trees,   nCores = 3, nChains = 3,   chainLength = 15000, verbose = FALSE ) vary_r_phylofit <- do.call(   rbind,   mclapply(vary_r_trees, phylofit,     mc.cores = 5, mc.silent = TRUE   ) )  # Make a list with each list element containing a data.frame of results for a # given r and method vary_r_results <- unlist(   list(     split(vary_r_lengths, r_vec),     split(vary_r_maxLike, r_vec),     split(vary_r_bdMCMC, r_vec),     split(vary_r_phylofit, r_vec)   ),   recursive = FALSE )  summary_r.df <- do.call(rbind, mapply(get_summary_stats, vary_r_results,   growthRate = as.numeric(names(vary_r_results)),   cloneAge = 40, SIMPLIFY = FALSE ))"},{"path":"https://bdj34.github.io/cloneRate/articles/reproduce-simResults.html","id":"random-r-fig--4","dir":"Articles","previous_headings":"Varying parameters > Varying r (and/or cloneAge) > Performance across r values","what":"Random r (Fig. 4)","title":"Reproduce simulation results","text":"order able apply estimates real-world cases growth rate known, need diagnostic tell us whether methods applicable. diagnostic tell us tree supercritical enough approximations hold. ratio external internal lengths measure “supercritical” star-shaped birth-death process . internal lengths top tree, consider star-shaped, ’s good candidate methods, operate assumption supercritical process. means growth rate high enough, enough time passed, coalescence events occur well sampling time. practice, using simulations, show external internal lengths ratio greater 3 good enough apply methods. Let’s apply methods see look applying ratio cutoff. Note ’re Figure 4 paper. Let’s simulate 10,000 trees 50 samples various growth rates, ranging 0.1 1 per year, run 40 years. , able dial ratio external internal lengths large enough work well methods. Apply internalLengths() maxLikelihood() functions usual, except want suppress warnings. warnings tell us external internal lengths ratio high enough trees, exactly ’re testing . different r values, can’t density plot . ’ll show density plot x axis representing percent error. case, good estimates consolidate around 0. First, ’ll calculate error using estimate column r_vec ground truth values.  bad, rogue estimates > 150% error! many > 50% error. external internal lengths ratio give good estimate supercritical tree . need figure ratio good enough assumptions valid methods work. method, let’s split results ratio external internal lengths, see accurate 95% confidence intervals : Let’s plot Figure 4A paper:  Seeing confidence intervals aren’t accurate ratio least 3, let’s apply cutoff ratio 3 exclude trees don’t think good candidates methods. Hopefully, get rid poor estimates.  ’d say ’s much better. cut 1,000 10,000 trees, eliminating many worst estimates. exact number trees removed change time analysis run. real advantage can look tree calculate ratio tell us right away methods applicable. Finally, let’s quantify see Root mean square error coverage probability, Figure 4D. ’ll start lengths method: maximum likelihood estimates: can construct table like Figure 4D:","code":"# Uniform ditribution of r used to generate b_vec r_vec <- stats::runif(n = 10000, min = 0.1, max = 1) a_vec <- stats::runif(n = 10000, min = 1, max = 3) b_vec <- a_vec - r_vec  # Input to simUltra() random_r_trees <- simUltra(   a = a_vec, b = b_vec, cloneAge = 40, n = 50,   nTrees = length(a_vec), nCores = 6 ) random_r_maxLike <- suppressWarnings(maxLikelihood(random_r_trees)) random_r_lengths <- suppressWarnings(internalLengths(random_r_trees)) # Calculate error in lengths, adding columns random_r_lengths$ground_truth <- r_vec random_r_lengths$percent_error <- 100 * (random_r_lengths$estimate - random_r_lengths$ground_truth) / random_r_lengths$ground_truth  # Do the same for maxLike random_r_maxLike$ground_truth <- r_vec random_r_maxLike$percent_error <- 100 * (random_r_maxLike$estimate - random_r_maxLike$ground_truth) / random_r_maxLike$ground_truth  # Combine for ggplot formatting results_random_r <- rbind(random_r_lengths, random_r_maxLike)  # Plot, adding a vertical line at 0 because that's the error free estimate ggplot(results_random_r) +   geom_density(aes(x = percent_error, color = method), linewidth = 1.5) +   geom_point(     aes(       x = percent_error, color = method,       y = runif(n = nrow(results_random_r), min = -.01, max = -.001)     ),     size = .1   ) +   geom_vline(xintercept = 0) +   theme_bw() +   xlim(-100, 2000) +   coord_cartesian(xlim = c(-100, 150)) +   theme(     axis.text.y = element_blank(), axis.ticks.y = element_blank(),     legend.title = element_blank()   ) +   xlab(\"Estimate percent error\") +   ylab(\"Density\") +   scale_color_manual(labels = c(\"Internal lengths\", \"Max. likelihood\"), values = c(\"black\", \"#009E73\")) # Split by the integer value of the ratio  # Make a dataframe to store the coverage probabilities covProbs.df <- data.frame(   \"intervalMin\" = NA,   \"intervalMax\" = NA,   \"coverageProb\" = NA,   \"method\" = NA,   \"count\" = NA )  # Calculate coverage probability at each interval of ext. to int. lengths ratio for (i in c(0:20)) {   # Get the subset that has a ratio in the interval i to i+1   lengths.tmp <- random_r_lengths[random_r_lengths$extIntRatio >= i &     random_r_lengths$extIntRatio < i + 1, ]   maxLike.tmp <- random_r_maxLike[random_r_maxLike$extIntRatio >= i &     random_r_maxLike$extIntRatio < i + 1, ]    coverageLengths <- sum(lengths.tmp$lowerBound < lengths.tmp$ground_truth &     lengths.tmp$upperBound > lengths.tmp$ground_truth) / nrow(lengths.tmp)   coverageMaxLike <- sum(maxLike.tmp$lowerBound < maxLike.tmp$ground_truth &     maxLike.tmp$upperBound > maxLike.tmp$ground_truth) / nrow(maxLike.tmp)    covProbs.df <- rbind(covProbs.df, data.frame(     \"intervalMin\" = i,     \"intervalMax\" = i + 1,     \"coverageProb\" = c(       coverageLengths,       coverageMaxLike     ),     \"method\" = c(\"lengths\", \"maxLike\"),     \"count\" = nrow(maxLike.tmp)   )) }  # Remove NA row from initialization covProbs.df <- covProbs.df[!is.na(covProbs.df$intervalMin), ] ggplot(covProbs.df) +   geom_segment(aes(     x = intervalMin, y = coverageProb,     xend = intervalMax, yend = coverageProb,     color = method   )) +   theme_bw() +   scale_color_manual(values = colorPal[c(1, 4)]) +   ylab(\"Coverage Probability\") +   xlab(\"External to internal lengths ratio\") +   theme(legend.title = element_blank()) +   geom_vline(xintercept = 3, linetype = \"dashed\") +   geom_hline(yintercept = 0.95, linetype = \"dotted\", linewidth = .5) # Cut those trees with ratio > 3 results_random_r_cut <- results_random_r[results_random_r$extIntRatio >= 3, ]  # How many did we cut print((nrow(results_random_r) - nrow(results_random_r_cut)) / 2) #> [1] 1154 # Plot the estimates after the diagnostic ggplot(results_random_r_cut) +   geom_density(aes(x = percent_error, color = method), linewidth = 1.5) +   geom_point(     aes(       x = percent_error, color = method,       y = runif(n = nrow(results_random_r_cut), min = -.01, max = -.001)     ),     size = .1   ) +   geom_vline(xintercept = 0) +   theme_bw() +   xlim(-100, 200) +   coord_cartesian(xlim = c(-100, 150)) +   theme(     axis.text.y = element_blank(), axis.ticks.y = element_blank(),     legend.title = element_blank()   ) +   xlab(\"Estimate percent error\") +   ylab(\"Density\") +   scale_color_manual(labels = c(\"Internal lengths\", \"Max. likelihood\"), values = c(\"black\", \"#009E73\")) # Get the lengths stats before the diagnostic normRMSE_before_lengths <- sqrt(sum(((random_r_lengths$estimate - random_r_lengths$ground_truth) /   random_r_lengths$ground_truth)^2) / nrow(random_r_lengths)) coverage_before_lengths <- sum(random_r_lengths$upperBound > random_r_lengths$ground_truth &   random_r_lengths$lowerBound < random_r_lengths$ground_truth) /   nrow(random_r_lengths)   # Get the lengths stats for those passing the diagnostic lengths_passing <- random_r_lengths[random_r_lengths$extIntRatio > 3, ] normRMSE_after_lengths <- sqrt(sum(((lengths_passing$estimate - lengths_passing$ground_truth) /   lengths_passing$ground_truth)^2) / nrow(lengths_passing))  coverage_after_lengths <- sum(lengths_passing$upperBound > lengths_passing$ground_truth &   lengths_passing$lowerBound < lengths_passing$ground_truth) /   nrow(lengths_passing) # Get the maxLike stats before the diagnostic normRMSE_before_maxLike <- sqrt(sum(((random_r_maxLike$estimate - random_r_maxLike$ground_truth) /   random_r_maxLike$ground_truth)^2 / nrow(random_r_maxLike))) coverage_before_maxLike <- sum(random_r_maxLike$upperBound > random_r_maxLike$ground_truth &   random_r_maxLike$lowerBound < random_r_maxLike$ground_truth) /   nrow(random_r_maxLike)   # Get the maxLike stats for those passing the diagnostic maxLike_passing <- random_r_maxLike[random_r_maxLike$extIntRatio > 3, ] normRMSE_after_maxLike <- sqrt(sum(((maxLike_passing$estimate - maxLike_passing$ground_truth) /   maxLike_passing$ground_truth)^2) / nrow(maxLike_passing))  coverage_after_maxLike <- sum(maxLike_passing$upperBound > maxLike_passing$ground_truth &   maxLike_passing$lowerBound < maxLike_passing$ground_truth) /   nrow(maxLike_passing) data.frame(   \"Value\" = c(     \"RMSE before\", \"RMSE after\", \"Coverage probability before\",     \"Coverage probability after\"   ),   \"Lengths\" = c(     normRMSE_before_lengths, normRMSE_after_lengths,     coverage_before_lengths, coverage_after_lengths   ),   \"Max likelihood\" = c(     normRMSE_before_maxLike, normRMSE_after_maxLike,     coverage_before_maxLike, coverage_after_maxLike   ) ) #>                         Value   Lengths Max.likelihood #> 1                 RMSE before 0.3915289      0.4652296 #> 2                  RMSE after 0.1650387      0.1614592 #> 3 Coverage probability before 0.8951000      0.8570000 #> 4  Coverage probability after 0.9493556      0.9262944"},{"path":"https://bdj34.github.io/cloneRate/articles/reproduce-simResults.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Reproduce simulation results","text":"method simulating trees direct result work Amaury Lambert following paper. mathematical methods estimating growth rates build large part work, linked : Lambert, . 2018 Phylofit used comparison direct result previous work: Williams et al. 2022 Mitchell et al. 2022 likelihood birth-death MCMC given Stadler Eq. 5 : Stadler, T. 2009 ’s final link paper details methods data analysis. aren’t many colors article, tried use colorblind friendly colors, specifically pulling colors palette designed Bang Wong available .","code":""},{"path":"https://bdj34.github.io/cloneRate/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Brian Johnson. Maintainer, author, copyright holder. Yubo Shuai. Author, copyright holder. Jason Schweinsberg. Author, copyright holder. Kit Curtius. Author, copyright holder.","code":""},{"path":"https://bdj34.github.io/cloneRate/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Johnson, B., Shuai, Y., Schweinsberg, J., Curtius, K. cloneRate: fast estimation single-cell clonal dynamics using coalescent theory. Bioinformatics, 2023.","code":"@Article{,   title = {cloneRate: fast estimation of single-cell clonal dynamics using coalescent theory},   author = {Brian Johnson and Yubo Shuai and Jason Schweinsberg and Kit Curtius},   journal = {Bioinformatics},   year = {2023},   url = {https://doi.org/10.1093/bioinformatics/btad561}, }"},{"path":"https://bdj34.github.io/cloneRate/index.html","id":"clonerate-","dir":"","previous_headings":"","what":"Estimate Growth Rates from Phylogenetic Trees","title":"Estimate Growth Rates from Phylogenetic Trees","text":"goal cloneRate provide easily accessible methods estimating growth rate clones. input either ultrametric phylogenetic tree edge lengths corresponding time, non-ultrametric phylogenetic tree edge lengths corresponding mutation counts. package provides internal lengths maximum likelihood methods ultrametric trees shared mutations method mutation-based trees, recent paper cloneRate: fast estimation single-cell clonal dynamics using coalescent theory. also provide birth-death Markov Chain Monte Carlo (MCMC) approach using probability density derived Eq. 5 Tanja Stadler’s work. test methods, provide fast way simulate coalescent (tree) sample birth-death branching process, direct result Amaury Lambert’s work.","code":""},{"path":"https://bdj34.github.io/cloneRate/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Estimate Growth Rates from Phylogenetic Trees","text":"Install CRAN following: Alternatively, can install development version cloneRate GitHub. basic tutorial vignettes, also use packages, can installed CRAN. listed packages ‘suggest’, running following command (dependencies = TRUE) install along vignettes: Alternatively, can install manually:","code":"install.packages(\"cloneRate\") # Install devtools if you don't have it already install.packages(setdiff(\"devtools\", rownames(installed.packages())))  # Install devtools::install_github(\"bdj34/cloneRate\", build_vignettes = TRUE, dependencies = TRUE) install.packages(setdiff(c(\"ggplot2\", \"ggsurvfit\", \"survival\", \"car\"), rownames(installed.packages())))"},{"path":"https://bdj34.github.io/cloneRate/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Estimate Growth Rates from Phylogenetic Trees","text":"’ll walk simulating single tree plotting . ’ll apply growth rate methods.","code":""},{"path":"https://bdj34.github.io/cloneRate/index.html","id":"simulate-data","dir":"","previous_headings":"Example","what":"Simulate data","title":"Estimate Growth Rates from Phylogenetic Trees","text":"can simulate sample size n birth-death tree follows: Now simulated tree, let’s plot :","code":"library(cloneRate) library(ape) library(ggplot2)  # Generate a sampled tree with 100 tips from a 20 year birth-death process with birth rate a=1 and death rate b=0.5 tree <- simUltra(a = 1, b = 0.5, cloneAge = 40, n = 100) # Plot, then add scale and title plot.phylo(tree,   direction = \"downwards\",   show.tip.label = FALSE, edge.width = 2 ) axisPhylo(side = 2, backward = FALSE, las = 1) title(main = \"Simulated ultrametric tree\", ylab = \"Time (years)\")"},{"path":"https://bdj34.github.io/cloneRate/index.html","id":"estimate-growth-rate-of-one-tree","dir":"","previous_headings":"Example","what":"Estimate growth rate of one tree","title":"Estimate Growth Rates from Phylogenetic Trees","text":"can use tree input methods growth rate estimation: ’re simulating new tree time, estimate change run, don’t worried results don’t match exactly.","code":"# Estimate the growth rate r=a-b=0.5 using maximum likelihood maxLike.df <- maxLikelihood(tree) print(paste0(\"Max. likelihood estimate = \", round(maxLike.df$estimate, 3))) #> [1] \"Max. likelihood estimate = 0.537\"  # Estimate the growth rate r=a-b=0.5 using internal lengths intLengths.df <- internalLengths(tree) print(paste0(\"Internal lengths estimate = \", round(intLengths.df$estimate, 3))) #> [1] \"Internal lengths estimate = 0.527\""},{"path":"https://bdj34.github.io/cloneRate/index.html","id":"estimate-growth-rate-of-many-trees","dir":"","previous_headings":"Example","what":"Estimate growth rate of many trees","title":"Estimate Growth Rates from Phylogenetic Trees","text":"paper, use simulated trees test growth rate estimates. example, let’s load simulated data comes package, exampleUltraTrees 100 ultrametric trees. “metadata” data.frame find ground truth growth rate, case 1. Let’s apply methods 100 trees. Notice functions maxLikelihood() internalLengths() can take input either single tree list trees. Either way, output data.frame containing results. Now 100 estimates 100 different trees 2 different methods, let’s plot distributions  Finally, let’s compute root mean square error (RMSE) estimates. expect maximum likelihood perform best RMSE, 100 relatively small sample size anything happen… expected, maximum likelihood performs best. Note may change regenerate data. details, see cloneRate website vignettes:","code":"# Here we are applying two methods to all of the ultrametric trees resultsUltraMaxLike <- maxLikelihood(exampleUltraTrees) resultsUltraLengths <- internalLengths(exampleUltraTrees) # Combine all into one df for plotting. This works because the columns are the same resultsCombined <- rbind(resultsUltraMaxLike, resultsUltraLengths)  # Plot, adding a vertical line at r=1 because that's the true growth rate ggplot(resultsCombined) +   geom_density(aes(x = estimate, color = method), linewidth = 1.5) +   geom_vline(xintercept = exampleUltraTrees[[1]]$metadata$r) +   theme_bw() +   theme(     axis.text.y = element_blank(), axis.ticks.y = element_blank(),     legend.title = element_blank()   ) +   xlab(\"Net growth rate estimate (r)\") +   ylab(\"Density\") +   scale_color_manual(labels = c(\"Internal lengths\", \"Max. likelihood\"), values = c(\"black\", \"#009E73\")) # Calculate the RMSE groundTruth <- exampleUltraTrees[[1]]$metadata$r[1] rmse <- unlist(lapply(   split(resultsCombined, resultsCombined$method),   function(x) {     sqrt(sum((x$estimate - groundTruth)^2) / length(x$estimate))   } ))  print(rmse) #>    lengths    maxLike  #> 0.09119116 0.08756432 vignette(\"cloneRate-dataAnalysis\", package = \"cloneRate\") vignette(\"cloneRate-simulate\", package = \"cloneRate\")"},{"path":"https://bdj34.github.io/cloneRate/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Estimate Growth Rates from Phylogenetic Trees","text":"Simulating birth-death trees direct result work Amaury Lambert : Lambert, 2018 package comes 42 clones annotated four distinct publications, ones use analysis. Note three clones profiled two different timepoints, meaning 39 unique clones. papers generate data : Williams et al. 2022 Mitchell et al. 2022 Fabre et al. 2022 Van Egeren et al. 2021 birth-death MCMC (shown ) based probability density derived Eq. 5 Tanja Stadler’s work: Stadler, 2009 mathematical basis estimates detailed full paper.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/birthDeathMCMC.html","id":null,"dir":"Reference","previous_headings":"","what":"Growth rate estimate using MCMC — birthDeathMCMC","title":"Growth rate estimate using MCMC — birthDeathMCMC","text":"Uses Rstan U-turn sampler approximate growth rate using likelihood Stadler 2009 \"incomplete sampling birth–death models connections sampling-based coalescent\"","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/birthDeathMCMC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Growth rate estimate using MCMC — birthDeathMCMC","text":"","code":"birthDeathMCMC(   tree,   maxGrowthRate = 4,   alpha = 0.05,   verbose = TRUE,   nChains = 4,   nCores = 1,   chainLength = 2000 )"},{"path":"https://bdj34.github.io/cloneRate/reference/birthDeathMCMC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Growth rate estimate using MCMC — birthDeathMCMC","text":"tree ultrametric tree subset include clone interest. Alternatively, list several trees. maxGrowthRate Sets upper bound birth rate. Default 4 depend nature data alpha Used calculation confidence intervals. 1-alpha confidence intervals used default alpha = 0.05 (95 percent confidence intervals) verbose TRUE FALSE, Rstan MCMC intermediate output progress printed? nChains Number chains run MCMC. Default 4 nCores Number cores perform MCMC. Default 1, chains can run parallel chainLength Number iterations chain MCMC. Default 2000 (1000 warm-+ 1000 sampling), increase stan tells ","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/birthDeathMCMC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Growth rate estimate using MCMC — birthDeathMCMC","text":"dataframe including net growth rate estimate, confidence intervals, important details (clone age estimate, runtime, n, etc.)","code":""},{"path":[]},{"path":"https://bdj34.github.io/cloneRate/reference/birthDeathMCMC.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Growth rate estimate using MCMC — birthDeathMCMC","text":"","code":"# \\donttest{ df <- birthDeathMCMC(cloneRate::exampleUltraTrees[[1]]) #>  #> CHECKING DATA AND PREPROCESSING FOR MODEL 'bdSampler' NOW. #>  #> COMPILING MODEL 'bdSampler' NOW. #>  #> STARTING SAMPLER FOR MODEL 'bdSampler' NOW. #>  #> SAMPLING FOR MODEL 'bdSampler' NOW (CHAIN 1). #> Chain 1:  #> Chain 1: Gradient evaluation took 0.000201 seconds #> Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 2.01 seconds. #> Chain 1: Adjust your expectations accordingly! #> Chain 1:  #> Chain 1:  #> Chain 1: Iteration:    1 / 2000 [  0%]  (Warmup) #> Chain 1: Iteration:  200 / 2000 [ 10%]  (Warmup) #> Chain 1: Iteration:  400 / 2000 [ 20%]  (Warmup) #> Chain 1: Iteration:  600 / 2000 [ 30%]  (Warmup) #> Chain 1: Iteration:  800 / 2000 [ 40%]  (Warmup) #> Chain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup) #> Chain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling) #> Chain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling) #> Chain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling) #> Chain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling) #> Chain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling) #> Chain 1: Iteration: 2000 / 2000 [100%]  (Sampling) #> Chain 1:  #> Chain 1:  Elapsed Time: 17.733 seconds (Warm-up) #> Chain 1:                22.367 seconds (Sampling) #> Chain 1:                40.1 seconds (Total) #> Chain 1:  #>  #> SAMPLING FOR MODEL 'bdSampler' NOW (CHAIN 2). #> Chain 2:  #> Chain 2: Gradient evaluation took 0.000144 seconds #> Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 1.44 seconds. #> Chain 2: Adjust your expectations accordingly! #> Chain 2:  #> Chain 2:  #> Chain 2: Iteration:    1 / 2000 [  0%]  (Warmup) #> Chain 2: Iteration:  200 / 2000 [ 10%]  (Warmup) #> Chain 2: Iteration:  400 / 2000 [ 20%]  (Warmup) #> Chain 2: Iteration:  600 / 2000 [ 30%]  (Warmup) #> Chain 2: Iteration:  800 / 2000 [ 40%]  (Warmup) #> Chain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup) #> Chain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling) #> Chain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling) #> Chain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling) #> Chain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling) #> Chain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling) #> Chain 2: Iteration: 2000 / 2000 [100%]  (Sampling) #> Chain 2:  #> Chain 2:  Elapsed Time: 18.12 seconds (Warm-up) #> Chain 2:                23.175 seconds (Sampling) #> Chain 2:                41.295 seconds (Total) #> Chain 2:  #>  #> SAMPLING FOR MODEL 'bdSampler' NOW (CHAIN 3). #> Chain 3:  #> Chain 3: Gradient evaluation took 0.000148 seconds #> Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 1.48 seconds. #> Chain 3: Adjust your expectations accordingly! #> Chain 3:  #> Chain 3:  #> Chain 3: Iteration:    1 / 2000 [  0%]  (Warmup) #> Chain 3: Iteration:  200 / 2000 [ 10%]  (Warmup) #> Chain 3: Iteration:  400 / 2000 [ 20%]  (Warmup) #> Chain 3: Iteration:  600 / 2000 [ 30%]  (Warmup) #> Chain 3: Iteration:  800 / 2000 [ 40%]  (Warmup) #> Chain 3: Iteration: 1000 / 2000 [ 50%]  (Warmup) #> Chain 3: Iteration: 1001 / 2000 [ 50%]  (Sampling) #> Chain 3: Iteration: 1200 / 2000 [ 60%]  (Sampling) #> Chain 3: Iteration: 1400 / 2000 [ 70%]  (Sampling) #> Chain 3: Iteration: 1600 / 2000 [ 80%]  (Sampling) #> Chain 3: Iteration: 1800 / 2000 [ 90%]  (Sampling) #> Chain 3: Iteration: 2000 / 2000 [100%]  (Sampling) #> Chain 3:  #> Chain 3:  Elapsed Time: 19.036 seconds (Warm-up) #> Chain 3:                22.501 seconds (Sampling) #> Chain 3:                41.537 seconds (Total) #> Chain 3:  #>  #> SAMPLING FOR MODEL 'bdSampler' NOW (CHAIN 4). #> Chain 4:  #> Chain 4: Gradient evaluation took 0.000123 seconds #> Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 1.23 seconds. #> Chain 4: Adjust your expectations accordingly! #> Chain 4:  #> Chain 4:  #> Chain 4: Iteration:    1 / 2000 [  0%]  (Warmup) #> Chain 4: Iteration:  200 / 2000 [ 10%]  (Warmup) #> Chain 4: Iteration:  400 / 2000 [ 20%]  (Warmup) #> Chain 4: Iteration:  600 / 2000 [ 30%]  (Warmup) #> Chain 4: Iteration:  800 / 2000 [ 40%]  (Warmup) #> Chain 4: Iteration: 1000 / 2000 [ 50%]  (Warmup) #> Chain 4: Iteration: 1001 / 2000 [ 50%]  (Sampling) #> Chain 4: Iteration: 1200 / 2000 [ 60%]  (Sampling) #> Chain 4: Iteration: 1400 / 2000 [ 70%]  (Sampling) #> Chain 4: Iteration: 1600 / 2000 [ 80%]  (Sampling) #> Chain 4: Iteration: 1800 / 2000 [ 90%]  (Sampling) #> Chain 4: Iteration: 2000 / 2000 [100%]  (Sampling) #> Chain 4:  #> Chain 4:  Elapsed Time: 21.475 seconds (Warm-up) #> Chain 4:                25.544 seconds (Sampling) #> Chain 4:                47.019 seconds (Total) #> Chain 4:  # }"},{"path":"https://bdj34.github.io/cloneRate/reference/cloneRate-package.html","id":null,"dir":"Reference","previous_headings":"","what":"The 'cloneRate' package. — cloneRate-package","title":"The 'cloneRate' package. — cloneRate-package","text":"Quickly estimate net growth rate population clone whose growth can approximated birth-death branching process.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/cloneRate-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"The 'cloneRate' package. — cloneRate-package","text":"Johnson et al. 2023 Bioinformatics. doi:10.1093/bioinformatics/btad561","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/coal_to_tree.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate tree from coalescence times — coal_to_tree","title":"Generate tree from coalescence times — coal_to_tree","text":"generates tree vector coalescence times randomly merging lineages.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/coal_to_tree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate tree from coalescence times — coal_to_tree","text":"","code":"coal_to_tree(coal_times)"},{"path":"https://bdj34.github.io/cloneRate/reference/coal_to_tree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate tree from coalescence times — coal_to_tree","text":"coal_times numeric vector coalescence times","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/coal_to_tree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate tree from coalescence times — coal_to_tree","text":"ape object class \"phylo\" representing ultrametric phylogenetic tree edge lengths units time.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/coal_to_tree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate tree from coalescence times — coal_to_tree","text":"","code":"# Generate an ape phylo tree with n tips from a vector of n-1 coalescence times randomCoalTimes <- c(9.3, 7.8, 10.15, 11.23, 9.4, 8.8, 10.01, 13) tree <- coal_to_tree(randomCoalTimes)"},{"path":"https://bdj34.github.io/cloneRate/reference/exampleMutTrees.html","id":null,"dir":"Reference","previous_headings":"","what":"Example mutation tree data — exampleMutTrees","title":"Example mutation tree data — exampleMutTrees","text":"Set 100 mutation based trees reconstructed distribution sample n=100 tips. trees net growth rate 1 birth rates 1 2 (sampled uniform distribution). Death rates equal chosen birth rate minus 1. Tree reconstruction uses exact distribution coalescence times described \"coalescent sample binary branching process\", Lambert ., Theor. Pop. Bio. 2018. Tree construction formatting uses ape R package ape::rcoal(). change edge lengths time-based mutation-based drawing poisson distribution mean equal edge length (units time) multiplied mutation rate, nu, drawn uniform distribution 10 20 mutations per year.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/exampleMutTrees.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example mutation tree data — exampleMutTrees","text":"","code":"data(exampleMutTrees)"},{"path":"https://bdj34.github.io/cloneRate/reference/exampleMutTrees.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example mutation tree data — exampleMutTrees","text":"list objects class phylo edge matrix edge connections reconstruct tree. edge.length numeric vector branch lengths connections edge matrix. Units mutations. tip.label character vector containing  (arbitrary case) labels 100 tips/samples tree. Nnode Integer number internal nodes tree params data.frame containing info params used generate tree","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/exampleMutTrees.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Example mutation tree data — exampleMutTrees","text":"data set created cloneRate package using coalescent theory approaches described \"coalescent sample binary branching process\", Lambert ., Theor. Pop. Bio. 2018.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/exampleMutTrees.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Example mutation tree data — exampleMutTrees","text":"","code":"# Plot first of 100 trees ape::plot.phylo(cloneRate::exampleMutTrees[[1]],   direction = \"downwards\", show.tip.label = FALSE )"},{"path":"https://bdj34.github.io/cloneRate/reference/exampleUltraTrees.html","id":null,"dir":"Reference","previous_headings":"","what":"Example ultrametric tree data — exampleUltraTrees","title":"Example ultrametric tree data — exampleUltraTrees","text":"Set 100 time-based ultrametric trees reconstructed distribution sample n=100 tips. trees net growth rate 1 birth rates 1 2 (sampled uniform distribution). Death rates equal chosen birth rate minus 1. Tree reconstruction uses exact distribution coalescence times described \"coalescent sample binary branching process\", Lambert ., Theor. Pop. Bio. 2018. Tree construction formatting uses ape R package ape::rcoal().","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/exampleUltraTrees.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example ultrametric tree data — exampleUltraTrees","text":"","code":"data(exampleUltraTrees)"},{"path":"https://bdj34.github.io/cloneRate/reference/exampleUltraTrees.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example ultrametric tree data — exampleUltraTrees","text":"list objects class phylo edge matrix edge connections reconstruct tree. edge.length numeric vector branch lengths connections edge matrix. Units years. tip.label character vector containing  (arbitrary case) labels 100 tips/samples tree. Nnode Integer number internal nodes tree params data.frame containing info params used generate tree","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/exampleUltraTrees.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Example ultrametric tree data — exampleUltraTrees","text":"data set created cloneRate package using coalescent theory approaches described \"coalescent sample binary branching process\", Lambert ., Theor. Pop. Bio. 2018.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/exampleUltraTrees.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Example ultrametric tree data — exampleUltraTrees","text":"","code":"# Plot first of 100 trees ape::plot.phylo(cloneRate::exampleUltraTrees[[1]],   direction = \"downwards\", show.tip.label = FALSE )"},{"path":"https://bdj34.github.io/cloneRate/reference/inputCheck.html","id":null,"dir":"Reference","previous_headings":"","what":"Check the inputs to growth rate functions — inputCheck","title":"Check the inputs to growth rate functions — inputCheck","text":"Check validity inputs growth rate fns, making sure tree ultrametric ape phylo object reasonable alpha","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/inputCheck.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check the inputs to growth rate functions — inputCheck","text":"","code":"inputCheck(tree, alpha)"},{"path":"https://bdj34.github.io/cloneRate/reference/inputCheck.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check the inputs to growth rate functions — inputCheck","text":"tree ape tree subset include clone interest alpha Used calculation confidence intervals. 1-alpha confidence intervals used default alpha = 0.05 (95 percent confidence intervals)","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/internalLengths.html","id":null,"dir":"Reference","previous_headings":"","what":"Growth rate estimate using the sum of internal lengths — internalLengths","title":"Growth rate estimate using the sum of internal lengths — internalLengths","text":"internalLengths() provides estimate net growth rate clone confidence bounds, using internal lengths method.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/internalLengths.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Growth rate estimate using the sum of internal lengths — internalLengths","text":"","code":"internalLengths(tree, alpha = 0.05)"},{"path":"https://bdj34.github.io/cloneRate/reference/internalLengths.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Growth rate estimate using the sum of internal lengths — internalLengths","text":"tree ultrametric tree subset include clone interest. Alternatively, list several trees. alpha Used calculation confidence intervals. 1-alpha confidence intervals used default alpha = 0.05 (95 percent confidence intervals)","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/internalLengths.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Growth rate estimate using the sum of internal lengths — internalLengths","text":"dataframe including net growth rate estimate, sum internal lengths important details (clone age estimate, runtime, n, etc.)","code":""},{"path":[]},{"path":"https://bdj34.github.io/cloneRate/reference/internalLengths.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Growth rate estimate using the sum of internal lengths — internalLengths","text":"","code":"internalLengths(cloneRate::exampleUltraTrees[[1]]) #>   lowerBound estimate upperBound cloneAgeEstimate sumInternalLengths #> 1  0.8729623 1.085769   1.298576         20.83863           92.10061 #>   sumExternalLengths extIntRatio   n alpha runtime_s  method #> 1           1547.141    16.79838 100  0.05     0.007 lengths"},{"path":"https://bdj34.github.io/cloneRate/reference/longitudinalData.html","id":null,"dir":"Reference","previous_headings":"","what":"Longitudinal validation data — longitudinalData","title":"Longitudinal validation data — longitudinalData","text":"three individuals clonal expansions can estimated using methods, longitudinal data orthogonally validate estimates, included . Additionally, 13 clones driver gene matching driver gene single cell data, without match specific clone, include longitudinal data well.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/longitudinalData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Longitudinal validation data — longitudinalData","text":"","code":"longitudinalData"},{"path":"https://bdj34.github.io/cloneRate/reference/longitudinalData.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Longitudinal validation data — longitudinalData","text":"data.frame containing information needed Sample.ID individual's ID Age Individual's age various sampling times VAF variant allele frequency various sampling times clone interest Gene Gene genes mutation identifies clone Protein Protein affected mutation cellType type cells used sequencing cloneName name use clone match single cell data, applicable.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/longitudinalData.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Longitudinal validation data — longitudinalData","text":"datasets generated annotated : Williams et al. 2022 Fabre et al. 2022","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/longitudinalData.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Longitudinal validation data — longitudinalData","text":"","code":"# Plot longitudinal data from PD9478 library(ggplot2) ggplot(longitudinalData[longitudinalData$Sample.ID == \"PD9478\", ]) +   geom_point(aes(x = Age, y = VAF))"},{"path":"https://bdj34.github.io/cloneRate/reference/maxLikelihood.html","id":null,"dir":"Reference","previous_headings":"","what":"Growth rate estimate using Maximum Likelihood — maxLikelihood","title":"Growth rate estimate using Maximum Likelihood — maxLikelihood","text":"Uses approximation coalescence times H_i equal +b*U_i find b. b equal 1/r, r net growth rate.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/maxLikelihood.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Growth rate estimate using Maximum Likelihood — maxLikelihood","text":"","code":"maxLikelihood(tree, alpha = 0.05)"},{"path":"https://bdj34.github.io/cloneRate/reference/maxLikelihood.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Growth rate estimate using Maximum Likelihood — maxLikelihood","text":"tree ultrametric tree subset include clone interest. Alternatively, list several trees. alpha Used calculation confidence intervals. 1-alpha confidence intervals used default alpha = 0.05 (95 percent confidence intervals)","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/maxLikelihood.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Growth rate estimate using Maximum Likelihood — maxLikelihood","text":"dataframe including net growth rate estimate, confidence intervals, important details (clone age estimate, runtime, n, etc.)","code":""},{"path":[]},{"path":"https://bdj34.github.io/cloneRate/reference/maxLikelihood.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Growth rate estimate using Maximum Likelihood — maxLikelihood","text":"","code":"df <- maxLikelihood(cloneRate::exampleUltraTrees[[1]])"},{"path":"https://bdj34.github.io/cloneRate/reference/realCloneData.html","id":null,"dir":"Reference","previous_headings":"","what":"Real clone data from human blood — realCloneData","title":"Real clone data from human blood — realCloneData","text":"42 clones (39 distinct) 32 individual donors, 13 diagnosis Myeloproliferative Neoplasm","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/realCloneData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Real clone data from human blood — realCloneData","text":"","code":"data(realCloneData)"},{"path":"https://bdj34.github.io/cloneRate/reference/realCloneData.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Real clone data from human blood — realCloneData","text":"list containing one list full ultrametric trees 30 32 individual donors (two Van Egeren included), one list containing 42 clone trees.three cases, two timepoints clone, separate phylo objects. list contains tree class phylo object. See ape package documentation details class phylo objects. Names phylo object (tree) list matches naming used sources also includes driver, age, clone number.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/realCloneData.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Real clone data from human blood — realCloneData","text":"datasets generated annotated : Williams et al. 2022 Mitchell et al. 2022 Fabre et al. 2022 Van Egeren et al. 2021","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/realCloneData.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Real clone data from human blood — realCloneData","text":"","code":"# Plot full reconstructed tree from donor PD34493 ape::plot.phylo(cloneRate::realCloneData[[\"fullTrees\"]][[\"PD34493\"]],   direction = \"downwards\", show.tip.label = FALSE )"},{"path":"https://bdj34.github.io/cloneRate/reference/sharedMuts.html","id":null,"dir":"Reference","previous_headings":"","what":"Growth rate estimate using the sum of shared mutations assuming a mutation tree — sharedMuts","title":"Growth rate estimate using the sum of shared mutations assuming a mutation tree — sharedMuts","text":"sharedMuts() provides estimate net growth rate clone confidence bounds, using shared mutations method.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/sharedMuts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Growth rate estimate using the sum of shared mutations assuming a mutation tree — sharedMuts","text":"","code":"sharedMuts(tree, nu = NULL, alpha = 0.05)"},{"path":"https://bdj34.github.io/cloneRate/reference/sharedMuts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Growth rate estimate using the sum of shared mutations assuming a mutation tree — sharedMuts","text":"tree non-ultrametric ape tree subset include clone interest nu mutation rate. none given, sharedMuts() first look nu column metadata data.frame tree, look nu tree . throw error nu given found. alpha Used calculation confidence intervals. 1-alpha confidence intervals used default alpha = 0.05 (95 percent confidence intervals)","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/sharedMuts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Growth rate estimate using the sum of shared mutations assuming a mutation tree — sharedMuts","text":"dataframe including net growth rate estimate, sum internal lengths important details (clone age estimate, runtime, n, etc.)","code":""},{"path":[]},{"path":"https://bdj34.github.io/cloneRate/reference/sharedMuts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Growth rate estimate using the sum of shared mutations assuming a mutation tree — sharedMuts","text":"","code":"sharedMuts(cloneRate::exampleMutTrees[[1]]) #>   lowerBound estimate upperBound       nu cloneAgeEstimate sharedMutations #> 1  0.7208325 0.907424   1.094015 18.46608         20.32646            2035 #>   privateMutations extIntRatio   n alpha runtime_s     method #> 1            24393    11.98673 100  0.05     0.008 sharedMuts"},{"path":"https://bdj34.github.io/cloneRate/reference/simMut.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate mutation-based birth and death branching trees — simMut","title":"Simulate mutation-based birth and death branching trees — simMut","text":"Generates sampled tree (list many sampled trees) supercritial (birth rate > death rate) birth death branching process according coalescent point process described \"Lambert, . coalescent sample binary branching process. (2018).\" Edge lengths units mutations, assuming poissonian mutation accumulation. Essentially wrapper combining simUltra() ultra2mut() functions one step.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/simMut.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate mutation-based birth and death branching trees — simMut","text":"","code":"simMut(   a,   b,   cloneAge,   n,   nu,   nTrees = 1,   precBits = 1000,   addStem = FALSE,   nCores = 1 )"},{"path":"https://bdj34.github.io/cloneRate/reference/simMut.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate mutation-based birth and death branching trees — simMut","text":"Birth rate b Death rate cloneAge Clone age. Make sure time units birth death rates n Number samples/tips tree returned nu Mutation rate units mutations per unit time. Make sure time units consistent birth death rates cloneAge nTrees Integer indicating number trees generate. Default 1. precBits Rmpfr param handling high precision numbers. Needed draw coalescence times. addStem Boolean indicating whether add stem tree preceding first split/coalescence nCores Integer indicating number cores use parallel pkg installed. Default 1.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/simMut.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate mutation-based birth and death branching trees — simMut","text":"ape object class \"phylo\" representing ultrametric phylogenetic tree edge lengths units time. Tree metadata located 'metadata' data.frame included \"phylo\" object. 'nTrees' param greater 1, simUltra returns list objects objects class \"phylo\".","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/simMut.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate mutation-based birth and death branching trees — simMut","text":"","code":"# Generate a single mutation-based tree with a specified mutation rate tree <- simMut(a = 1, b = 0.5, cloneAge = 40, n = 50, nu = 10)  # Generate a list of mutation-based trees with a range of mutation rates tree_list <- simMut(   a = 1, b = 0.5, cloneAge = 40, n = 50,   nu = stats::runif(n = 3, min = 10, max = 20), nTrees = 3 )"},{"path":"https://bdj34.github.io/cloneRate/reference/simUltra.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate ultrametric birth and death branching trees — simUltra","title":"Simulate ultrametric birth and death branching trees — simUltra","text":"Generates sampled tree (list many sampled trees) supercritial (birth rate > death rate) birth death branching process according coalescent point process described \"Lambert, . coalescent sample binary branching process. (2018).\"","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/simUltra.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate ultrametric birth and death branching trees — simUltra","text":"","code":"simUltra(   a,   b,   cloneAge,   n,   nTrees = 1,   precBits = 1000,   addStem = FALSE,   nCores = 1 )"},{"path":"https://bdj34.github.io/cloneRate/reference/simUltra.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate ultrametric birth and death branching trees — simUltra","text":"Birth rate vector birth rates length 'nTrees' b Death rate vector death rates length 'nTrees' cloneAge Clone age vector clone ages length 'nTrees'. Make sure time units birth death rates n Number samples/tips tree returned. Can vector length 'nTrees' well. nTrees Integer indicating number trees generate. Default 1 precBits Rmpfr param handling high precision numbers. Needed drawing coalescence times. Can vector length 'nTrees', though recommended addStem Boolean indicating whether add stem tree preceding first split/coalescence. Can also vector length 'nTrees' nCores Integer indicating number cores use parallel pkg installed. Default 1.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/simUltra.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate ultrametric birth and death branching trees — simUltra","text":"ape object class \"phylo\" representing ultrametric phylogenetic tree edge lengths units time. Tree metadata located 'metadata' data.frame included \"phylo\" object. 'nTrees' param greater 1, simUltra returns list objects objects class \"phylo\".","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/simUltra.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate ultrametric birth and death branching trees — simUltra","text":"","code":"# Generate a single tree tree <- simUltra(a = 1, b = 0.5, cloneAge = 20, n = 50)  # Generate a list of trees tree_list <- simUltra(a = 1, b = 0.5, cloneAge = 20, n = 50, nTrees = 3)"},{"path":"https://bdj34.github.io/cloneRate/reference/siteFrequency.html","id":null,"dir":"Reference","previous_headings":"","what":"Get site frequency spectrum of a tree — siteFrequency","title":"Get site frequency spectrum of a tree — siteFrequency","text":"siteFrequency() calculates site frequency units time mutations, well normalized frequency.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/siteFrequency.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get site frequency spectrum of a tree — siteFrequency","text":"","code":"siteFrequency(tree, includeStem = FALSE)"},{"path":"https://bdj34.github.io/cloneRate/reference/siteFrequency.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get site frequency spectrum of a tree — siteFrequency","text":"tree ultrametric mutation-based tree subset include clone interest. Alternatively, list several trees. includeStem Boolean indicating whether count stem tree contributing site frequency distribution. Default FALSE.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/siteFrequency.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get site frequency spectrum of a tree — siteFrequency","text":"data.frame three columns: number descendant cells, site frequency units time mutations, normalized site frequency. list trees input, output list data.frames.","code":""},{"path":[]},{"path":"https://bdj34.github.io/cloneRate/reference/siteFrequency.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get site frequency spectrum of a tree — siteFrequency","text":"","code":"# Get site frequency of a single tree example.df <- siteFrequency(exampleUltraTrees[[1]])  # Get site frequency of a list of trees example.list <- siteFrequency(exampleMutTrees)"},{"path":"https://bdj34.github.io/cloneRate/reference/ultra2mut.html","id":null,"dir":"Reference","previous_headings":"","what":"Add poissonian mutations to an ultrametric tree(s) — ultra2mut","title":"Add poissonian mutations to an ultrametric tree(s) — ultra2mut","text":"Takes ultrametric tree class \"phylo\" (list trees) draws new edge lengths units mutations, mean new edge length equal old edge length multiplied mutation rate. Mutation rate can set drawn uniform distribution.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/ultra2mut.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add poissonian mutations to an ultrametric tree(s) — ultra2mut","text":"","code":"ultra2mut(tree, nu)"},{"path":"https://bdj34.github.io/cloneRate/reference/ultra2mut.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add poissonian mutations to an ultrametric tree(s) — ultra2mut","text":"tree single tree list trees class \"phylo\", edge lengths units time nu Mutation rate units mutations per unit time. Can also vector mutation rates length equal number input trees. Make sure time units consistent nu tree$edge.length","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/ultra2mut.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add poissonian mutations to an ultrametric tree(s) — ultra2mut","text":"ape object class \"phylo\" representing phylogenetic tree edge lengths units mutations. Value mutation rate added 'metadata' data.frame output tree data.frame exists input tree. Otherwise, mutation rate value added \"phylo\" object directly. input list trees, ultra2mut() return list \"phylo\" objects.","code":""},{"path":"https://bdj34.github.io/cloneRate/reference/ultra2mut.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add poissonian mutations to an ultrametric tree(s) — ultra2mut","text":"","code":"# Convert the time-based, ultrametric example trees into mutation-based trees mutTrees <- ultra2mut(exampleUltraTrees,   nu = stats::runif(n = length(exampleUltraTrees), min = 10, max = 20) )"},{"path":[]},{"path":"https://bdj34.github.io/cloneRate/news/index.html","id":"clonerate-023","dir":"Changelog","previous_headings":"","what":"cloneRate 0.2.3","title":"cloneRate 0.2.3","text":"CRAN release: 2023-09-22 Minor changes CRAN resubmission","code":""},{"path":"https://bdj34.github.io/cloneRate/news/index.html","id":"clonerate-022","dir":"Changelog","previous_headings":"","what":"cloneRate 0.2.2","title":"cloneRate 0.2.2","text":"Wrap long-running examples  CRAN","code":""},{"path":"https://bdj34.github.io/cloneRate/news/index.html","id":"clonerate-021","dir":"Changelog","previous_headings":"","what":"cloneRate 0.2.1","title":"cloneRate 0.2.1","text":"Change CRAN installation instructions README","code":""},{"path":[]},{"path":"https://bdj34.github.io/cloneRate/news/index.html","id":"update-for-cran-compatibility-0-2-0","dir":"Changelog","previous_headings":"","what":"Update for CRAN compatibility","title":"cloneRate 0.2.0","text":"Make birth-death MCMC available users package Move rstan suggests imports Update rstan methods consistent rstantools recommendations","code":""},{"path":[]},{"path":"https://bdj34.github.io/cloneRate/news/index.html","id":"add-birth-death-mcmc-0-1-0","dir":"Changelog","previous_headings":"","what":"Add birth-death MCMC","title":"cloneRate 0.1.0","text":"Add birth death MCMC targeting likelihood equation 5 Stadler 2009 “incomplete sampling birth–death models connections sampling-based coalescent” Implements MCMC using rstan package, now listed suggests","code":""},{"path":"https://bdj34.github.io/cloneRate/news/index.html","id":"clonerate-001","dir":"Changelog","previous_headings":"","what":"cloneRate 0.0.1","title":"cloneRate 0.0.1","text":"Added NEWS.md file track changes package.","code":""}]
